---
layout: post
title: OCaml 99 问题笔记（Logic and Codes 部分）
date:  2024-9-2 9:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

开始搞得有点像编译原理了哦，很神秘。

### 41. Truth Tables for Logical Expressions (2 Variables)

>Let us define a small "language" for boolean expressions containing variables:

```
# type bool_expr =
  | Var of string
  | Not of bool_expr
  | And of bool_expr * bool_expr
  | Or of bool_expr * bool_expr;;
type bool_expr =
    Var of string
  | Not of bool_expr
  | And of bool_expr * bool_expr
  | Or of bool_expr * bool_expr
```

> A logical expression in two variables can then be written in prefix notation. For example, `(a ∨ b) ∧ (a ∧ b)` is written:

```
# And (Or (Var "a", Var "b"), And (Var "a", Var "b"));;
- : bool_expr = And (Or (Var "a", Var "b"), And (Var "a", Var "b"))
```

> Define a function, `table2` which returns the truth table of a given logical expression in two variables (specified as arguments). The return value must be a list of triples containing `(value_of_a, value_of_b, value_of_expr)`.

```
# table2 "a" "b" (And (Var "a", Or (Var "a", Var "b")));;
- : (bool * bool * bool) list =
[(true, true, true); (true, false, true); (false, true, false);
 (false, false, false)]
```

```
# table2 "a" "b" (And (Var "a", Or (Var "a", Var "b")));;
- : (bool * bool * bool) list =
[(true, true, true); (true, false, true); (false, true, false);
 (false, false, false)]
```

额啊，题好长。还好是固定参数的，好像 OCaml 函数只能固定参数数量。

表驱动，懂？太对劲了。

```
let table2 one two exp = 
	let rec eval exp (fir, sec)= match exp with
		| Var e -> if e = one then fir else sec
		| Not e -> not (eval e (fir, sec))
		| And (e1, e2) -> (eval e1 (fir, sec)) && (eval e2 (fir, sec))
		| Or (e1, e2) -> (eval e1 (fir, sec)) || (eval e2 (fir, sec))
	in
	List.map (fun (a,b) -> (a, b, (eval exp (a, b))) )  [(true, true); (true, false); (false, true); (false, false)];;

val table2 : string -> 'a -> bool_expr -> (bool * bool * bool) list = <fun>

```

我的函数签名还不太一样，第二个参数没有限制，这是怎么做到的，问题是第一个参数的类型限制又是什么时候加上的呢？有什么是依赖 string 的吗？OCaml 的类型推断，真的很神秘。

```
# let rec eval2 a val_a b val_b = function
    | Var x -> if x = a then val_a
               else if x = b then val_b
               else failwith "The expression contains an invalid variable"
    | Not e -> not (eval2 a val_a b val_b e)
    | And(e1, e2) -> eval2 a val_a b val_b e1 && eval2 a val_a b val_b e2
    | Or(e1, e2) -> eval2 a val_a b val_b e1 || eval2 a val_a b val_b e2
  let table2 a b expr =
    [(true,  true,  eval2 a true  b true  expr);
     (true,  false, eval2 a true  b false expr);
     (false, true,  eval2 a false b true  expr);
     (false, false, eval2 a false b false expr)];;
val eval2 : string -> bool -> string -> bool -> bool_expr -> bool = <fun>
val table2 : string -> string -> bool_expr -> (bool * bool * bool) list =
  <fun>
```

### 42.  Truth Tables for Logical Expressions

> Generalize the previous problem in such a way that the logical expression may contain any number of logical variables. Define `table` in a way that `table variables expr` returns the truth table for the expression `expr`, which contains the logical variables enumerated in `variables`.

这下任意数量参数了。得搞个 map 了。

写了我好久，这种过程较为复杂的情况，声明式的语言就优势一点。好吧，可能也没啥优势，就是我不熟 OCaml 的库函数。

说起来，OCaml 的 Map 还是有序的，fold 文档里说 where `k1 ... kN` are the keys of all bindings in `m` (in increasing order) 这么看底层是什么情况呢，链表吗。

```
let table vars exp= let module VarTable = Map.Make(String) in
	let rec get_input l before= match l with
		| [] -> [before]
		| h::t -> (get_input t ((h, true)::before)) @ (get_input t ((h, false)::before))
	in
	let rec into_map l m= match l with 
		| [] -> m
		| (name, value)::t -> into_map t (VarTable.add name value m)
	in
	let var_maps = List.map (fun e -> into_map e VarTable.empty) (get_input vars []) in 

	let rec eval inner_exp var_map= match inner_exp with
		| Var e -> VarTable.find e var_map
		| Not e -> not (eval e var_map)
		| And (e1, e2) -> (eval e1 var_map) && (eval e2 var_map)
		| Or (e1, e2) -> (eval e1 var_map) || (eval e2 var_map)
	in
	List.map (fun m -> ((VarTable.fold (fun k v acc-> acc@ [(k,v)]) m []), (eval exp m))) var_maps;;

val table :
  String.t list -> bool_expr -> ((String.t * bool) list * bool) list = <fun>

```

哦，List.assoc 这么牛的吗，当 map 用了，我还老老实实用 map 了，不过估计是 O(n) 的。

```
# (* [val_vars] is an associative list containing the truth value of
     each variable.  For efficiency, a Map or a Hashtlb should be
     preferred. *)

  let rec eval val_vars = function
    | Var x -> List.assoc x val_vars
    | Not e -> not (eval val_vars e)
    | And(e1, e2) -> eval val_vars e1 && eval val_vars e2
    | Or(e1, e2) -> eval val_vars e1 || eval val_vars e2

  (* Again, this is an easy and short implementation rather than an
     efficient one. *)
  let rec table_make val_vars vars expr =
    match vars with
    | [] -> [(List.rev val_vars, eval val_vars expr)]
    | v :: tl ->
         table_make ((v, true) :: val_vars) tl expr
       @ table_make ((v, false) :: val_vars) tl expr

  let table vars expr = table_make [] vars expr;;
val eval : (string * bool) list -> bool_expr -> bool = <fun>
val table_make :
  (string * bool) list ->
  string list -> bool_expr -> ((string * bool) list * bool) list = <fun>
val table : string list -> bool_expr -> ((string * bool) list * bool) list =
  <fun>

```



# 总结

