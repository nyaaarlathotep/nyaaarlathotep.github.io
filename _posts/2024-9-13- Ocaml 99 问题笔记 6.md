---
layout: post
title: OCaml 99 问题笔记（Graphs 部分）
date:  2024-9-13 21:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

### 67. Conversions

> ![A graph](https://ocaml.org/media/problems/graph1.gif)
>
> *A graph is defined as a set of nodes and a set of edges, where each edge is a pair of different nodes.*
>
> There are several ways to represent graphs in OCaml.
>
> - One method is to list all edges, an edge being a pair of nodes. In this form, the graph depicted opposite is represented as the following expression:
>
> ```
> # [('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')];;
> - : (char * char) list =
> [('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')]
> ```
>
> We call this **edge-clause form**. Obviously, isolated nodes cannot be represented.
>
> - Another method is to represent the whole graph as one data object. According to the definition of the graph as a pair of two sets (nodes and edges), we may use the following OCaml type:
>
> ```
> # type 'a graph_term = {nodes : 'a list;  edges : ('a * 'a) list};;
> type 'a graph_term = { nodes : 'a list; edges : ('a * 'a) list; }
> ```
>
> Then, the above example graph is represented by:
>
> ```
> # let example_graph =
>   {nodes = ['b'; 'c'; 'd'; 'f'; 'g'; 'h'; 'k'];
>    edges = [('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')]};;
> val example_graph : char graph_term =
>   {nodes = ['b'; 'c'; 'd'; 'f'; 'g'; 'h'; 'k'];
>    edges = [('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')]}
> ```
>
> We call this **graph-term form**. Note, that the lists are kept sorted, they are really sets, without duplicated elements. Each edge appears only once in the edge list; i.e. an edge from a node x to another node y is represented as `(x, y)`, the couple `(y, x)` is not present. The **graph-term form is our default representation.** You may want to define a similar type using sets instead of lists.
>
> - A third representation method is to associate with each node the set of nodes that are adjacent to that node. We call this the **adjacency-list form**. In our example:
>
> ```
>     (* example pending *)
> ```
>
> - The representations we introduced so far well suited for automated processing, but their syntax is not very user-friendly. Typing the terms by hand is cumbersome and error-prone. We can define a more compact and "human-friendly" notation as follows: A graph (with char labelled nodes) is represented by a string of atoms and terms of the type X-Y. The atoms stand for isolated nodes, the X-Y terms describe edges. If an X appears as an endpoint of an edge, it is automatically defined as a node. Our example could be written as:
>
> ```
> # "b-c f-c g-h d f-b k-f h-g";;
> - : string = "b-c f-c g-h d f-b k-f h-g"
> ```
>
> We call this the **human-friendly form**. As the example shows, the list does not have to be sorted and may even contain the same edge multiple times. Notice the isolated node `d`.
>
> Write functions to convert between the different graph representations. With these functions, all representations are equivalent; i.e. for the following problems you can always pick freely the most convenient form. This problem is not particularly difficult, but it's a lot of work to deal with all the special cases.

`adjacency-list form`定义都没给我怎么转化啊。

```
let human_to_graph s= let h_edges = String.split_on_char ' ' s in
	let add_node node ns = 
		if not (List.exists (fun e -> e = node) ns) 
				then node::ns else ns
	in
	let rec aux l ns es= match l with
		| [] -> {nodes = ns;edges = es}
		| p::t -> 
			let (ns,es) = if String.length p = 1 then(add_node p.[0] ns, es)
            else
			let ns = add_node p.[0] ns in
			let ns = add_node p.[2] ns in
			let es = if not (List.exists (fun e -> e=(p.[0], p.[2])) es) 
				then (p.[0], p.[2])::es else es in
			(ns, es) in
			aux t ns es
	in
	aux h_edges [] []
```

又没答案。

### Path From One Node to Another One

> Write a function `paths g a b` that returns all acyclic path `p` from node `a` to node `b ≠ a` in the graph `g`. The function should return the list of all paths via backtracking.
>
> ```
> # let example_graph =
>   {nodes = ['b'; 'c'; 'd'; 'f'; 'g'; 'h'; 'k'];
>    edges = [('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')]};;
> val example_graph : char graph_term =
>   {nodes = ['b'; 'c'; 'd'; 'f'; 'g'; 'h'; 'k'];
>    edges = [('h', 'g'); ('k', 'f'); ('f', 'b'); ('f', 'c'); ('c', 'b')]}
> # paths example_graph 'f' 'b';;
> - : char list list = [['f'; 'c'; 'b']; ['f'; 'b']]
> ```

感觉得写一些通用的图的方法。比如 list.contain 这种的，有无环判断真的很麻烦。

哦，List.assoc 来了，只有 exist 没有 contain，但又有 assoc 这种，癌，是什么想法呢。

```
let paths graph =  
```



# 总结

