---
layout: post
title: The Little Schemer 读后感
date:  2024-7-28 9:00:00 +0900
description: 我花了几天浏览了一下这本书，这是我偶然在看到有人聊函数式的时候推荐的。在这里总结一下我的收获与一些疑问。
categories: [总结, Scheme]
keywords: The Little Schemer
essays: true   
---

# 前言

这本书使用 Scheme，以一个个例子展开，从最基本的要素开始，一步一步发展出了函数式中很多重要的内容，如果对于函数式有兴趣想要深入了解，但不想接触太多的数学内容，倾向于循序渐进，从例子中学习，可以阅读本书。

# 书

- 以对话问答的形式组织，提出问题，给出解答，你可以自己解答问题再和作者给出的解答对照，很有意思
- 内容循序渐进
    - 后面章节的内容经常依赖前面的内容，因此都得跟着敲一遍，也得理解前面的内容
    - 在书的最后的附录有函数的页数索引
    - 前面的章节会详细的，一步一步地拆解过程，甚至有些繁琐，然而后面会越来越快，简单来说，我越到后面看的越慢
- 代码就是凝练的逻辑本身，代码自身胜于解说，比起很多先有代码再对其进行解释的书，本书不会有这个重复的过程，你需要自己看代码
- 奇妙的 Scheme 五法和十诫，贯穿了本书，看完背不下来也心中有数了
- 真正从微小的基本内容，慢慢生长，到达了函数式的重要内容，currying, continuation, Y 组合子等等，灵光一闪领悟到它在做的事情的时候真的很巧妙
- 对食物的执念，名词全是吃的

# Scheme

完美的教具！

- 保留关键字和语法式少，不用特意学习，跟随本书使用即可。让我们可以聚焦在逻辑本身上
    - 后续内容都是我们自己定义，产出的，运算符都是我们自己定义的
- 灵活，s-表达式可以表示原子或者 list，所以你永远要处理嵌套
- 代码就是凝练的逻辑本身，不会有多余的内容。感慨啊，命令式的语言不会有这样的体验
- 最后一章是自己给自己实现一个编译器，实现的很顺畅，感觉 Scheme 自身的语法的天然简洁让这一章内容直指编译器的一些本质的数据结构和过程，恐怖如斯啊
- 还有一点，我本地没装环境，这个在线 playground 难以 debug，报错都不知道式哪一行爆出来的，那么多括号还有 cond 又容易少加多加，有点痛苦

顺便附上 [在线 playground](https://www.w3cschool.cn/tryrun/runcode?lang=scheme-chez)

# 遗留的几个问题

- cdr 这不就是切片吗，用切片和递归来实现循环，强啊
- Schema 的数据结构是怎么组织的？是栈，堆的经典结构吗？应该不是，那么递归和返回是怎么在内存里组织的？
- add1 这种实际意义是什么，计算机的 cpu 计算 add1 和其他更大的整型加法应该是一样的效果，是为了什么设计的呢？单纯的为了符合 lambda 还是有其他地方有使用价值？
    - 这个问题在第六章又有了一点新的含义。我们在用阿拉伯数字表示数字，然而还能用其他东西来表示数字，比如 1->(), 2->(())，这时候仅仅需要改变 add1，sub1 就能适应新的表示法了，就像是把建筑移植到了新的一片土地上，上面的内容一点也不需要更改！
- 编译原理？似曾相识啊，都是前缀表达式，Scheme 看起来也很好自我扩展
- 说起来，Scheme 都是惰性求值的吧，天生的，如果执行不到甚至不会报语法错

# 几张图

第九章推演过程太复杂了，稍微画了一下。

![p163](/images/Schemer/p163.png)
![p164](/images/Schemer/p164.png)
![p165](/images/Schemer/p165.png)
![p172](/images/Schemer/p172.png)

# 总结

自己推一编看着它演化和直接学还是不太一样，体会挺多。有没有勇气学学 SICP 呢。