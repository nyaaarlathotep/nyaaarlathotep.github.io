---
layout: post
title: OCaml 99 问题笔记（Binary Trees 部分）
date:  2024-9-8 9:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

### 45. Construct Completely Balanced Binary Trees

>
> ![Binary Tree](https://ocaml.org/media/problems/binary-tree.gif)
>
> *A binary tree is either empty or it is composed of a root element and two successors, which are binary trees themselves.*
>
> In OCaml, one can define a new type `binary_tree` that carries an arbitrary value of type `'a` (thus is polymorphic) at each node.
>
> ```
> # type 'a binary_tree =
>   | Empty
>   | Node of 'a * 'a binary_tree * 'a binary_tree;;
> type 'a binary_tree = Empty | Node of 'a * 'a binary_tree * 'a binary_tree
> ```
>
> An example of tree carrying `char` data is:
>
> ```
> # let example_tree =
>   Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
>        Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)));;
> val example_tree : char binary_tree =
>   Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
>    Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)))
> ```
>
> In OCaml, the strict type discipline *guarantees* that, if you get a value of type `binary_tree`, then it must have been created with the two constructors `Empty` and `Node`.
>
> In a completely balanced binary tree, the following property holds for every node: The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, which means their difference is not greater than one.
>
> Write a function `cbal_tree` to construct completely balanced binary trees for a given number of nodes. The function should generate all solutions via backtracking. Put the letter `'x'` as information into all nodes of the tree.
>
> ```
> # cbal_tree 4;;
> - : char binary_tree/2 list =
> [Node ('x', Node ('x', Empty, Empty),
>   Node ('x', Node ('x', Empty, Empty), Empty));
>  Node ('x', Node ('x', Empty, Empty),
>   Node ('x', Empty, Node ('x', Empty, Empty)));
>  Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>   Node ('x', Empty, Empty));
>  Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>   Node ('x', Empty, Empty))]
> ```

奇妙啊，这图还是 gif 格式的，意思是比 jpg 更小？

backtracking 在哪了，交换左右数量吗？那也行。

```
let rec cbal_tree num = match num with
	| 0 -> [Empty]
	| 1 -> [Node ('x', Empty, Empty)]
	| n -> 
		let left = (n-1)/2 in let right = n-1-left in 
		if left = right then 
			let nodes = cbal_tree left in
			List.flatten (List.map (fun l -> List.map (fun r -> Node('x', l, r)) nodes) nodes)
		else
			let left_num_nodes = cbal_tree left in
			let right_num_nodes = cbal_tree right in
			List.flatten (List.map (fun l -> List.map (fun r -> Node('x', l, r)) right_num_nodes) left_num_nodes) @ List.flatten (List.map (fun l -> List.map (fun r -> Node('x', l, r)) left_num_nodes) right_num_nodes);;

val cbal_tree : int -> char binary_tree list = <fun>

```

看起来 fold_left 就是个针对 acc 特化的函数，这样就不存在我这种 list 嵌套还得打平多余的一步了。

```
# (* Build all trees with given [left] and [right] subtrees. *)
  let add_trees_with left right all =
    let add_right_tree all l =
      List.fold_left (fun a r -> Node ('x', l, r) :: a) all right in
    List.fold_left add_right_tree all left

  let rec cbal_tree n =
    if n = 0 then [Empty]
    else if n mod 2 = 1 then
      let t = cbal_tree (n / 2) in
      add_trees_with t t []
    else (* n even: n-1 nodes for the left & right subtrees altogether. *)
      let t1 = cbal_tree (n / 2 - 1) in
      let t2 = cbal_tree (n / 2) in
      add_trees_with t1 t2 (add_trees_with t2 t1 []);;
val add_trees_with :
  char binary_tree list ->
  char binary_tree list -> char binary_tree list -> char binary_tree list =
  <fun>
val cbal_tree : int -> char binary_tree list = <fun>

```

### 46. Symmetric Binary Trees

> Let us call a binary tree symmetric if you can draw a vertical line through the root node and then the right subtree is the mirror image of the left subtree. Write a function `is_symmetric` to check whether a given binary tree is symmetric.
>
> **Hint:** Write a function `is_mirror` first to check whether one tree is the mirror image of another. We are only interested in the structure, not in the contents of the nodes.

来了来了，感觉像在做 LeetCode。这个提示有啥用呢，不是同时就对比了，还用搞这么麻烦吗。不对，撒情况，没有测试用例吗。

```
let rec is_symmetric t1 t2 = match t1 with
	| Empty -> let res = match t2 with 
		| Empty -> true
		| _ -> false
		in
		res
	| Node(t1v,t1l,t1r) -> match t2 with 
		| Empty -> false
		| Node(t2v,t2l,t2r) -> t1v=t2v && is_symmetric t1l t2r && is_symmetric t1r t2l;;

val is_symmetric : 'a binary_tree -> 'a binary_tree -> bool = <fun>

```

哦，弱智了，原来这个意思。。。我改下

```
let rec is_symmetric t = 
	let rec is_mirror t1 t2 =
    match t1, t2 with
    | Empty, Empty -> true
    | Node(_, l1, r1), Node(_, l2, r2) ->
       is_mirror l1 r2 && is_mirror r1 l2
    | _ -> false
    in
	match t with
		| Empty -> true
		| Node(_, l, r) -> is_mirror l r;;

val is_symmetric : 'a binary_tree -> bool = <fun>

```

还是你牛，还能这么 match 的。。。

```
# let rec is_mirror t1 t2 =
    match t1, t2 with
    | Empty, Empty -> true
    | Node(_, l1, r1), Node(_, l2, r2) ->
       is_mirror l1 r2 && is_mirror r1 l2
    | _ -> false

  let is_symmetric = function
    | Empty -> true
    | Node(_, l, r) -> is_mirror l r;;
val is_mirror : 'a binary_tree -> 'b binary_tree -> bool = <fun>
val is_symmetric : 'a binary_tree -> bool = <fun>

```

### 47. Binary Search Trees (Dictionaries)

> Construct a [binary search tree](http://en.wikipedia.org/wiki/Binary_search_tree) from a list of integer numbers.
>
> ```
> # construct [3; 2; 5; 7; 1];;
> - : int binary_tree =
> Node (3, Node (2, Node (1, Empty, Empty), Empty),
>  Node (5, Empty, Node (7, Empty, Empty)))
> ```
>
> Then use this function to test the solution of the previous problem.
>
> ```
> # is_symmetric (construct [5; 3; 18; 1; 4; 12; 21]);;
> - : bool = true
> # not (is_symmetric (construct [3; 2; 5; 7; 4]));;
> - : bool = true
> ```

奥，这道题测上道题。

```
let construct nums = 
	let rec add root next = match root with
		| Empty -> Node(next, Empty, Empty)
		| Node(v,l,r) -> if next>v then Node(v,l,(add r next)) else Node(v,(add l next),r)
	in
	let rec build remain root = match remain with
		| [] -> root
		| h::t -> build t (add root h) 
	in
	match nums with
		| [] -> Empty
		| h::t -> build t (Node(h, Empty, Empty))
```

哦，牛逼，好像是这么个意思，就是 fold_left 啊，简化了好多。

```
# let rec insert tree x = match tree with
    | Empty -> Node (x, Empty, Empty)
    | Node (y, l, r) ->
       if x = y then tree
       else if x < y then Node (y, insert l x, r)
       else Node (y, l, insert r x)
  let construct l = List.fold_left insert Empty l;;
val insert : 'a binary_tree -> 'a -> 'a binary_tree = <fun>
val construct : 'a list -> 'a binary_tree = <fun>

```

### 48. Generate-and-Test Paradigm

> Apply the generate-and-test paradigm to construct all symmetric, completely balanced binary trees with a given number of nodes.
>
> ```
> # sym_cbal_trees 5;;
> - : char binary_tree list =
> [Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>   Node ('x', Empty, Node ('x', Empty, Empty)));
>  Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>   Node ('x', Node ('x', Empty, Empty), Empty))]
> ```
>
> How many such trees are there with 57 nodes? Investigate about how many solutions there are for a given number of nodes? What if the number is even? Write an appropriate function.
>
> ```
> # List.length (sym_cbal_trees 57);;
> - : int = 256
> ```

组合一下的意思？

```
let sym_cbal_trees n = 
	let all = cbal_tree n in
	List.filter (fun t -> is_symmetric t) all;;

val sym_cbal_trees : int -> char binary_tree list = <fun>

```

```
# let sym_cbal_trees n =
    List.filter is_symmetric (cbal_tree n);;
val sym_cbal_trees : int -> char binary_tree list = <fun>

```

### 49. Construct Height-Balanced Binary Trees

> In a height-balanced binary tree, the following property holds for every node: The height of its left subtree and the height of its right subtree are almost equal, which means their difference is not greater than one.
>
> Write a function `hbal_tree` to construct height-balanced binary trees for a given height. The function should generate all solutions via backtracking. Put the letter `'x'` as information into all nodes of the tree.
>
> ```
> # let t = hbal_tree 3;;
> val t : char binary_tree list =
>   [Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Empty, Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Empty, Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Empty, Empty));
>    Node ('x', Node ('x', Empty, Empty),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Empty, Empty),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Empty, Empty),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)))]
> ```

换高度了。让我试试 fold_left。

```
let add_trees_with left right all = 
	let add_right_tree all l =
    	List.fold_left (fun a r -> Node ('x', l, r) :: a) all right in
    List.fold_left add_right_tree all left
let rec hbal_tree h = match h with
	| 1 -> [Node('x', Empty, Empty)]
	| 2 -> [Node('x', Node('x', Empty, Empty), Empty);Node('x', Empty, Node('x', Empty, Empty));Node('x', Node('x', Empty, Empty), Node('x', Empty, Empty))]
	| n -> add_trees_with (hbal_tree (n-1)) (hbal_tree (n-1)) (add_trees_with (hbal_tree (n-1)) (hbal_tree (n-2)) (add_trees_with (hbal_tree (n-2)) (hbal_tree (n-1)) []))
```

不是，这咋验证啊，太多了盯不过来。

```
# let rec hbal_tree n =
    if n = 0 then [Empty]
    else if n = 1 then [Node ('x', Empty, Empty)]
    else
    (* [add_trees_with left right trees] is defined in a question above. *)
      let t1 = hbal_tree (n - 1)
      and t2 = hbal_tree (n - 2) in
      add_trees_with t1 t1 (add_trees_with t1 t2 (add_trees_with t2 t1 []));;
val hbal_tree : int -> char binary_tree list = <fun>

```

### 50. Construct Height-Balanced Binary Trees With a Given Number of Nodes

> Consider a height-balanced binary tree of height `h`. What is the maximum number of nodes it can contain? Clearly, max_nodes = 2`h` - 1.
>
> ```
> # let max_nodes h = 1 lsl h - 1;;
> val max_nodes : int -> int = <fun>
> ```
>
> ## Minimum of nodes
>
> However, what is the minimum number min_nodes? This question is more difficult. Try to find a recursive statement and turn it into a function `min_nodes` defined as follows: `min_nodes h` returns the minimum number of nodes in a height-balanced binary tree of height `h`.
>
> ## Minimum height
>
> On the other hand, we might ask: what are the minimum (resp. maximum) height H a height-balanced binary tree with N nodes can have? `min_height` (resp. `max_height n`) returns the minimum (resp. maximum) height of a height-balanced binary tree with `n` nodes.
>
> ## Constructing trees
>
> Now, we can attack the main problem: construct all the height-balanced binary trees with a given number of nodes. `hbal_tree_nodes n` returns a list of all height-balanced binary tree with `n` nodes.
>
> Find out how many height-balanced trees exist for `n = 15`.
>
> ```
> # List.length (hbal_tree_nodes 15);;
> - : int = 1553
> ```

你这一道顶三道啊，头疼。



# 总结

