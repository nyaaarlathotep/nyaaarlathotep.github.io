---
layout: post
title: OCaml 99 问题笔记（Binary Trees 部分）
date:  2024-9-8 9:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

### 45. Construct Completely Balanced Binary Trees

>
> ![Binary Tree](https://ocaml.org/media/problems/binary-tree.gif)
>
> *A binary tree is either empty or it is composed of a root element and two successors, which are binary trees themselves.*
>
> In OCaml, one can define a new type `binary_tree` that carries an arbitrary value of type `'a` (thus is polymorphic) at each node.
>
> ```
> # type 'a binary_tree =
>   | Empty
>   | Node of 'a * 'a binary_tree * 'a binary_tree;;
> type 'a binary_tree = Empty | Node of 'a * 'a binary_tree * 'a binary_tree
> ```
>
> An example of tree carrying `char` data is:
>
> ```
> # let example_tree =
>   Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
>        Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)));;
> val example_tree : char binary_tree =
>   Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
>    Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)))
> ```
>
> In OCaml, the strict type discipline *guarantees* that, if you get a value of type `binary_tree`, then it must have been created with the two constructors `Empty` and `Node`.
>
> In a completely balanced binary tree, the following property holds for every node: The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, which means their difference is not greater than one.
>
> Write a function `cbal_tree` to construct completely balanced binary trees for a given number of nodes. The function should generate all solutions via backtracking. Put the letter `'x'` as information into all nodes of the tree.
>
> ```
> # cbal_tree 4;;
> - : char binary_tree/2 list =
> [Node ('x', Node ('x', Empty, Empty),
>   Node ('x', Node ('x', Empty, Empty), Empty));
>  Node ('x', Node ('x', Empty, Empty),
>   Node ('x', Empty, Node ('x', Empty, Empty)));
>  Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>   Node ('x', Empty, Empty));
>  Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>   Node ('x', Empty, Empty))]
> ```

奇妙啊，这图还是 gif 格式的，意思是比 jpg 更小？

backtracking 在哪了，交换左右数量吗？那也行。

```
let rec cbal_tree num = match num with
	| 0 -> [Empty]
	| 1 -> [Node ('x', Empty, Empty)]
	| n -> 
		let left = (n-1)/2 in let right = n-1-left in 
		if left = right then 
			let nodes = cbal_tree left in
			List.flatten (List.map (fun l -> List.map (fun r -> Node('x', l, r)) nodes) nodes)
		else
			let left_num_nodes = cbal_tree left in
			let right_num_nodes = cbal_tree right in
			List.flatten (List.map (fun l -> List.map (fun r -> Node('x', l, r)) right_num_nodes) left_num_nodes) @ List.flatten (List.map (fun l -> List.map (fun r -> Node('x', l, r)) left_num_nodes) right_num_nodes);;

val cbal_tree : int -> char binary_tree list = <fun>

```

看起来 fold_left 就是个针对 acc 特化的函数，这样就不存在我这种 list 嵌套还得打平多余的一步了。

```
# (* Build all trees with given [left] and [right] subtrees. *)
  let add_trees_with left right all =
    let add_right_tree all l =
      List.fold_left (fun a r -> Node ('x', l, r) :: a) all right in
    List.fold_left add_right_tree all left

  let rec cbal_tree n =
    if n = 0 then [Empty]
    else if n mod 2 = 1 then
      let t = cbal_tree (n / 2) in
      add_trees_with t t []
    else (* n even: n-1 nodes for the left & right subtrees altogether. *)
      let t1 = cbal_tree (n / 2 - 1) in
      let t2 = cbal_tree (n / 2) in
      add_trees_with t1 t2 (add_trees_with t2 t1 []);;
val add_trees_with :
  char binary_tree list ->
  char binary_tree list -> char binary_tree list -> char binary_tree list =
  <fun>
val cbal_tree : int -> char binary_tree list = <fun>

```

### 46. Symmetric Binary Trees

> Let us call a binary tree symmetric if you can draw a vertical line through the root node and then the right subtree is the mirror image of the left subtree. Write a function `is_symmetric` to check whether a given binary tree is symmetric.
>
> **Hint:** Write a function `is_mirror` first to check whether one tree is the mirror image of another. We are only interested in the structure, not in the contents of the nodes.

来了来了，感觉像在做 LeetCode。这个提示有啥用呢，不是同时就对比了，还用搞这么麻烦吗。不对，撒情况，没有测试用例吗。

```
let rec is_symmetric t1 t2 = match t1 with
	| Empty -> let res = match t2 with 
		| Empty -> true
		| _ -> false
		in
		res
	| Node(t1v,t1l,t1r) -> match t2 with 
		| Empty -> false
		| Node(t2v,t2l,t2r) -> t1v=t2v && is_symmetric t1l t2r && is_symmetric t1r t2l;;

val is_symmetric : 'a binary_tree -> 'a binary_tree -> bool = <fun>

```

哦，弱智了，原来这个意思。。。我改下

```
let rec is_symmetric t = 
	let rec is_mirror t1 t2 =
    match t1, t2 with
    | Empty, Empty -> true
    | Node(_, l1, r1), Node(_, l2, r2) ->
       is_mirror l1 r2 && is_mirror r1 l2
    | _ -> false
    in
	match t with
		| Empty -> true
		| Node(_, l, r) -> is_mirror l r;;

val is_symmetric : 'a binary_tree -> bool = <fun>

```

还是你牛，还能这么 match 的。。。

```
# let rec is_mirror t1 t2 =
    match t1, t2 with
    | Empty, Empty -> true
    | Node(_, l1, r1), Node(_, l2, r2) ->
       is_mirror l1 r2 && is_mirror r1 l2
    | _ -> false

  let is_symmetric = function
    | Empty -> true
    | Node(_, l, r) -> is_mirror l r;;
val is_mirror : 'a binary_tree -> 'b binary_tree -> bool = <fun>
val is_symmetric : 'a binary_tree -> bool = <fun>

```

### 47. Binary Search Trees (Dictionaries)

> Construct a [binary search tree](http://en.wikipedia.org/wiki/Binary_search_tree) from a list of integer numbers.
>
> ```
> # construct [3; 2; 5; 7; 1];;
> - : int binary_tree =
> Node (3, Node (2, Node (1, Empty, Empty), Empty),
>  Node (5, Empty, Node (7, Empty, Empty)))
> ```
>
> Then use this function to test the solution of the previous problem.
>
> ```
> # is_symmetric (construct [5; 3; 18; 1; 4; 12; 21]);;
> - : bool = true
> # not (is_symmetric (construct [3; 2; 5; 7; 4]));;
> - : bool = true
> ```

奥，这道题测上道题。

```
let construct nums = 
	let rec add root next = match root with
		| Empty -> Node(next, Empty, Empty)
		| Node(v,l,r) -> if next>v then Node(v,l,(add r next)) else Node(v,(add l next),r)
	in
	let rec build remain root = match remain with
		| [] -> root
		| h::t -> build t (add root h) 
	in
	match nums with
		| [] -> Empty
		| h::t -> build t (Node(h, Empty, Empty))
```

哦，牛逼，好像是这么个意思，就是 fold_left 啊，简化了好多。

```
# let rec insert tree x = match tree with
    | Empty -> Node (x, Empty, Empty)
    | Node (y, l, r) ->
       if x = y then tree
       else if x < y then Node (y, insert l x, r)
       else Node (y, l, insert r x)
  let construct l = List.fold_left insert Empty l;;
val insert : 'a binary_tree -> 'a -> 'a binary_tree = <fun>
val construct : 'a list -> 'a binary_tree = <fun>

```

### 48. Generate-and-Test Paradigm

> Apply the generate-and-test paradigm to construct all symmetric, completely balanced binary trees with a given number of nodes.
>
> ```
> # sym_cbal_trees 5;;
> - : char binary_tree list =
> [Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>   Node ('x', Empty, Node ('x', Empty, Empty)));
>  Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>   Node ('x', Node ('x', Empty, Empty), Empty))]
> ```
>
> How many such trees are there with 57 nodes? Investigate about how many solutions there are for a given number of nodes? What if the number is even? Write an appropriate function.
>
> ```
> # List.length (sym_cbal_trees 57);;
> - : int = 256
> ```

组合一下的意思？

```
let sym_cbal_trees n = 
	let all = cbal_tree n in
	List.filter (fun t -> is_symmetric t) all;;

val sym_cbal_trees : int -> char binary_tree list = <fun>

```

```
# let sym_cbal_trees n =
    List.filter is_symmetric (cbal_tree n);;
val sym_cbal_trees : int -> char binary_tree list = <fun>

```

### 49. Construct Height-Balanced Binary Trees

> In a height-balanced binary tree, the following property holds for every node: The height of its left subtree and the height of its right subtree are almost equal, which means their difference is not greater than one.
>
> Write a function `hbal_tree` to construct height-balanced binary trees for a given height. The function should generate all solutions via backtracking. Put the letter `'x'` as information into all nodes of the tree.
>
> ```
> # let t = hbal_tree 3;;
> val t : char binary_tree list =
>   [Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Empty, Node ('x', Empty, Empty)),
>     Node ('x', Empty, Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Empty),
>     Node ('x', Empty, Empty));
>    Node ('x', Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)),
>     Node ('x', Empty, Empty));
>    Node ('x', Node ('x', Empty, Empty),
>     Node ('x', Empty, Node ('x', Empty, Empty)));
>    Node ('x', Node ('x', Empty, Empty),
>     Node ('x', Node ('x', Empty, Empty), Empty));
>    Node ('x', Node ('x', Empty, Empty),
>     Node ('x', Node ('x', Empty, Empty), Node ('x', Empty, Empty)))]
> ```

换高度了。让我试试 fold_left。

```
let add_trees_with left right all = 
	let add_right_tree all l =
    	List.fold_left (fun a r -> Node ('x', l, r) :: a) all right in
    List.fold_left add_right_tree all left
let rec hbal_tree h = match h with
	| 1 -> [Node('x', Empty, Empty)]
	| 2 -> [Node('x', Node('x', Empty, Empty), Empty);Node('x', Empty, Node('x', Empty, Empty));Node('x', Node('x', Empty, Empty), Node('x', Empty, Empty))]
	| n -> add_trees_with (hbal_tree (n-1)) (hbal_tree (n-1)) (add_trees_with (hbal_tree (n-1)) (hbal_tree (n-2)) (add_trees_with (hbal_tree (n-2)) (hbal_tree (n-1)) []))
```

不是，这咋验证啊，太多了盯不过来。

```
# let rec hbal_tree n =
    if n = 0 then [Empty]
    else if n = 1 then [Node ('x', Empty, Empty)]
    else
    (* [add_trees_with left right trees] is defined in a question above. *)
      let t1 = hbal_tree (n - 1)
      and t2 = hbal_tree (n - 2) in
      add_trees_with t1 t1 (add_trees_with t1 t2 (add_trees_with t2 t1 []));;
val hbal_tree : int -> char binary_tree list = <fun>

```

### 50. Construct Height-Balanced Binary Trees With a Given Number of Nodes

> Consider a height-balanced binary tree of height `h`. What is the maximum number of nodes it can contain? Clearly, max_nodes = 2`h` - 1.
>
> ```
> # let max_nodes h = 1 lsl h - 1;;
> val max_nodes : int -> int = <fun>
> ```
>
> ## Minimum of nodes
>
> However, what is the minimum number min_nodes? This question is more difficult. Try to find a recursive statement and turn it into a function `min_nodes` defined as follows: `min_nodes h` returns the minimum number of nodes in a height-balanced binary tree of height `h`.
>
> ## Minimum height
>
> On the other hand, we might ask: what are the minimum (resp. maximum) height H a height-balanced binary tree with N nodes can have? `min_height` (resp. `max_height n`) returns the minimum (resp. maximum) height of a height-balanced binary tree with `n` nodes.
>
> ## Constructing trees
>
> Now, we can attack the main problem: construct all the height-balanced binary trees with a given number of nodes. `hbal_tree_nodes n` returns a list of all height-balanced binary tree with `n` nodes.
>
> Find out how many height-balanced trees exist for `n = 15`.
>
> ```
> 	# List.length (hbal_tree_nodes 15);;
> - : int = 1553
> ```

你这一道顶三道啊，头疼。癌，好像都是必要的前置步骤了，我服了。

```
let rec min_nodes n = if n = 0 then 0 
	else if n=1 then 1
	else (min_nodes (n-1))+1+(min_nodes (n-2))
```

```
let min_height n = 	
	let rec aux count = if (int_pow 2 count)-1>=n then count else aux (count+1) in
	aux 0
```

```
let max_height n = 
	let rec aux now = if min_nodes now<=n then aux (now+1) else now-1
	in
	aux 0
```

受不了了，这个回溯太麻烦了，直接抄。完了，答案也看不懂了。

看了半天了，呃呃呃，和我想得差不多，先找到 nodes 对应的可能的所有高度，然后对应子树的高度可能为（h-1，h-1），（h-1，h-2），还有互换左右支的情况。同时，再把总的 nodes 分配到左右支，这又是一个遍历，并同时保证左右支的平衡（这里直接递归了）。

巧妙的是这个 fold_range 的运用，这两次遍历都用这个了，acc 到最后的结果，很方便。但这个 ~ 是什么意思啊，而且定义里的参数的位置和标准答案里的参数的位置不一样，什么意思。

```
# let rec fold_range ~f ~init n0 n1 =
    if n0 > n1 then init else fold_range ~f ~init:(f init n0) (n0 + 1) n1;;
val fold_range : f:('a -> int -> 'a) -> init:'a -> int -> int -> 'a = <fun>
```

还有那个经典的两遍 fold_left，让两个列表作为左右子树结合出了所有可能的结果。

```
        List.fold_left (fun l t1 ->
            List.fold_left (fun l t2 -> Node ('x', t1, t2) :: l) l t2) l t1
      )
```

交换左右子树，并积累结果。

```
# let rec add_swap_left_right trees =
    List.fold_left (fun a n -> match n with
                               | Node (v, t1, t2) -> Node (v, t2, t1) :: a
                               | Empty -> a) trees trees;;
val add_swap_left_right : 'a binary_tree list -> 'a binary_tree list = <fun>
```

标准答案：

```
# let rec hbal_tree_nodes_height h n =
    assert(min_nodes h <= n && n <= max_nodes h);
    if h = 0 then [Empty]
    else
      let acc = add_hbal_tree_node [] (h - 1) (h - 2) n in
      let acc = add_swap_left_right acc in
      add_hbal_tree_node acc (h - 1) (h - 1) n
  and add_hbal_tree_node l h1 h2 n =
    let min_n1 = max (min_nodes h1) (n - 1 - max_nodes h2) in
    let max_n1 = min (max_nodes h1) (n - 1 - min_nodes h2) in
    fold_range min_n1 max_n1 ~init:l ~f:(fun l n1 ->
        let t1 = hbal_tree_nodes_height h1 n1 in
        let t2 = hbal_tree_nodes_height h2 (n - 1 - n1) in
        List.fold_left (fun l t1 ->
            List.fold_left (fun l t2 -> Node ('x', t1, t2) :: l) l t2) l t1
      )
      let hbal_tree_nodes n =
    fold_range (min_height n) (max_height n) ~init:[] ~f:(fun l h ->
        List.rev_append (hbal_tree_nodes_height h n) l);;
val hbal_tree_nodes_height : int -> int -> char binary_tree list = <fun>
val add_hbal_tree_node :
  char binary_tree list -> int -> int -> int -> char binary_tree list = <fun>
val hbal_tree_nodes : int -> char binary_tree list = <fun>

```

### 51. Count the Leaves of a Binary Tree

> A leaf is a node with no successors. Write a function `count_leaves` to count them.
>
> ```
> # count_leaves Empty;;
> - : int = 0
> ```

雷姆了，终于正常多了。

```
let rec count_leaves root = match root with
	| Empty -> 0
	| Node(v, Empty, Empty) -> 1
	| Node(b, l, r) -> count_leaves l + count_leaves r;;

val count_leaves : 'a binary_tree -> int = <fun>

```

```
# let rec count_leaves = function
    | Empty -> 0
    | Node (_, Empty, Empty) -> 1
    | Node (_, l, r) -> count_leaves l + count_leaves r;;
val count_leaves : 'a binary_tree -> int = <fun>

```

### 52. Collect the Leaves of a Binary Tree in a List

> A leaf is a node with no successors. Write a function `leaves` to collect them in a list.
>
> ```
> # leaves Empty;;
> - : 'a list = []
> ```

```
let rec leaves root =  match root with
	| Empty -> []
	| Node(v, Empty, Empty) -> [v]
	| Node(b, l, r) -> leaves l @ leaves r;;

val leaves : 'a binary_tree -> 'a list = <fun>

```

癌，被标准答案预判了。

```
# (* Having an accumulator acc prevents using inefficient List.append.
   * Every Leaf will be pushed directly into accumulator.
   * Not tail-recursive, but that is no problem since we have a binary tree and
   * and stack depth is logarithmic. *)
  let leaves t = 
    let rec leaves_aux t acc = match t with
      | Empty -> acc
      | Node (x, Empty, Empty) -> x :: acc
      | Node (x, l, r) -> leaves_aux l (leaves_aux r acc)
    in
    leaves_aux t [];;
val leaves : 'a binary_tree -> 'a list = <fun>
```

### 53. Collect the Internal Nodes of a Binary Tree in a List

> An internal node of a binary tree has either one or two non-empty successors. Write a function `internals` to collect them in a list.
>
> ```
> # internals (Node ('a', Empty, Empty));;
> - : char list = []
> ```

```
let internals t = 
	let rec aux root acc = match root with
		| Empty -> acc
        | Node (x, Empty, Empty) -> acc
        | Node (x, l, r) -> aux l (aux r (Node(x, l, r)::acc))
    in
    aux t [];;

val internals : 'a binary_tree -> 'b list = <fun>

```

哦，最好保持顺序，中序，我这个是什么鬼顺序，根 右 左。

```
# (* Having an accumulator acc prevents using inefficient List.append.
   * Every internal node will be pushed directly into accumulator.
   * Not tail-recursive, but that is no problem since we have a binary tree and
   * and stack depth is logarithmic. *)
  let internals t = 
    let rec internals_aux t acc = match t with
      | Empty -> acc
      | Node (x, Empty, Empty) -> acc
      | Node (x, l, r) -> internals_aux l (x :: internals_aux r acc)
    in
    internals_aux t [];;
val internals : 'a binary_tree -> 'a list = <fun>

```

### 54. Collect the Nodes at a Given Level in a List

> A node of a binary tree is at level N if the path from the root to the node has length N-1. The root node is at level 1. Write a function `at_level t l` to collect all nodes of the tree `t` at level `l` in a list.
>
> ```
> # let example_tree =
>   Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
>        Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)));;
> val example_tree : char binary_tree =
>   Node ('a', Node ('b', Node ('d', Empty, Empty), Node ('e', Empty, Empty)),
>    Node ('c', Empty, Node ('f', Node ('g', Empty, Empty), Empty)))
> # at_level example_tree 2;;
> - : char list = ['b'; 'c']
> ```
>
> Using `at_level` it is easy to construct a function `levelorder` which creates the level-order sequence of the nodes. However, there are more efficient ways to do that.

```
let at_level root height = 
	let rec aux r h acc = match r with
		| Empty -> acc
		| Node(v, l, r) -> if h=1 then v::acc 
			else aux l (h-1) (aux r (h-1) acc)
	in
	aux root height [];;

val at_level : 'a binary_tree -> int -> 'a list = <fun>
```

又和我方向反了，我这个算更正统的递归好吧。

```
# (* Having an accumulator acc prevents using inefficient List.append.
   * Every node at level N will be pushed directly into accumulator.
   * Not tail-recursive, but that is no problem since we have a binary tree and
   * and stack depth is logarithmic. *)
  let at_level t level =
    let rec at_level_aux t acc counter = match t with
      | Empty -> acc
      | Node (x, l, r) ->
        if counter=level then
          x :: acc
        else
          at_level_aux l (at_level_aux r acc (counter + 1)) (counter + 1)
    in
      at_level_aux t [] 1;;
val at_level : 'a binary_tree -> int -> 'a list = <fun>
```

### 55. Construct a Complete Binary Tree

> A *complete* binary tree with height H is defined as follows: The levels 1,2,3,...,H-1 contain the maximum number of nodes (i.e 2i-1 at the level i, note that we start counting the levels from 1 at the root). In level H, which may contain less than the maximum possible number of nodes, all the nodes are "left-adjusted". This means that in a levelorder tree traversal all internal nodes come first, the leaves come second, and empty successors (the nil's which are not really nodes!) come last.
>
> Particularly, complete binary trees are used as data structures (or addressing schemes) for heaps.
>
> We can assign an address number to each node in a complete binary tree by enumerating the nodes in levelorder, starting at the root with number 1. In doing so, we realize that for every node X with address A the following property holds: The address of X's left and right successors are 2*A and 2*A+1, respectively, supposed the successors do exist. This fact can be used to elegantly construct a complete binary tree structure. Write a function `is_complete_binary_tree` with the following specification: `is_complete_binary_tree n t` returns `true` iff `t` is a complete binary tree with `n` nodes.
>
> ```
> # complete_binary_tree [1; 2; 3; 4; 5; 6];;
> - : int binary_tree =
> Node (1, Node (2, Node (4, Empty, Empty), Node (5, Empty, Empty)),
>  Node (3, Node (6, Empty, Empty), Empty))
> ```

OCaml，或者说这些函数式语言，列表取址是 O(n) 的啊，还有什么好方法吗？

```
let complete_binary_tree list = 
	let rec get_index i l= match l with
		| []-> raise Not_found
		| h::t -> if i = 1 then h else get_index (i-1) t
	in
	let rec make_node index = if index>List.length list then Empty else
		Node(get_index index list, make_node (2*index), make_node (2*index + 1))
	in
	make_node 1
```

split 吗，神秘啊，没太看明白。哦，这个 lsl 是逻辑左移位。

我好像又看明白了，比起我每次都寻址，它做了个切片，少了些重复递归的过程，然后也是递归了，用 myflatten。

```
# let rec split_n lst acc n = match (n, lst) with
    | (0, _) -> (List.rev acc, lst)
    | (_, []) -> (List.rev acc, [])
    | (_, h :: t) -> split_n t (h :: acc) (n-1)

  let rec myflatten p c = 
    match (p, c) with
    | (p, []) -> List.map (fun x -> Node (x, Empty, Empty)) p
    | (x :: t, [y]) -> Node (x, y, Empty) :: myflatten t []
    | (ph :: pt, x :: y :: t) -> (Node (ph, x, y)) :: myflatten pt t
    | _ -> invalid_arg "myflatten"

  let complete_binary_tree = function
    | [] -> Empty
    | lst ->
       let rec aux l = function
         | [] -> []
         | lst -> let p, c = split_n lst [] (1 lsl l) in
                  myflatten p (aux (l + 1) c)
       in
         List.hd (aux 0 lst);;
val split_n : 'a list -> 'a list -> int -> 'a list * 'a list = <fun>
val myflatten : 'a list -> 'a binary_tree list -> 'a binary_tree list = <fun>
val complete_binary_tree : 'a list -> 'a binary_tree = <fun>

```

### 56. Layout a Binary Tree (1)

> As a preparation for drawing the tree, a layout algorithm is required to determine the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is shown in the illustration.
>
> ![Binary Tree Grid](https://ocaml.org/media/problems/tree-layout1.gif)
>
> In this layout strategy, the position of a node v is obtained by the following two rules:
>
> - *x(v)* is equal to the position of the node v in the *inorder* sequence;
> - *y(v)* is equal to the depth of the node *v* in the tree.
>
> In order to store the position of the nodes, we will enrich the value at each node with the position `(x,y)`.
>
> The tree pictured above is
>
> ```
> # let example_layout_tree =
>   let leaf x = Node (x, Empty, Empty) in
>   Node ('n', Node ('k', Node ('c', leaf 'a',
>                            Node ('h', Node ('g', leaf 'e', Empty), Empty)),
>                  leaf 'm'),
>        Node ('u', Node ('p', Empty, Node ('s', leaf 'q', Empty)), Empty));;
> val example_layout_tree : char binary_tree =
>   Node ('n',
>    Node ('k',
>     Node ('c', Node ('a', Empty, Empty),
>      Node ('h', Node ('g', Node ('e', Empty, Empty), Empty), Empty)),
>     Node ('m', Empty, Empty)),
>    Node ('u', Node ('p', Empty, Node ('s', Node ('q', Empty, Empty), Empty)),
>     Empty))
> # layout_binary_tree_1 example_layout_tree;;
> - : (char * int * int) binary_tree =
> Node (('n', 8, 1),
>  Node (('k', 6, 2),
>   Node (('c', 2, 3), Node (('a', 1, 4), Empty, Empty),
>    Node (('h', 5, 4),
>     Node (('g', 4, 5), Node (('e', 3, 6), Empty, Empty), Empty), Empty)),
>   Node (('m', 7, 3), Empty, Empty)),
>  Node (('u', 12, 2),
>   Node (('p', 9, 3), Empty,
>    Node (('s', 11, 4), Node (('q', 10, 5), Empty, Empty), Empty)),
>   Empty))
> ```

好说好说。

```
let layout_binary_tree_1 root = 
	let rec aux left_start node depth = match node with
		| Empty -> (left_start,Empty)
		| Node(v,l,r) -> let left_num, left_tree = aux left_start l (depth+1) in
			let right_num, right_tree = aux (left_num+1) r (depth + 1) in
        	(right_num, Node((v, left_num, depth), left_tree, right_tree))
    in
	let (total_num, r) = aux 1 root 1 in
	r;;

val layout_binary_tree_1 : 'a binary_tree -> ('a * int * int) binary_tree =
  <fun>

```

这不是完全一样吗。改下，不用最后这步多余的了。

```
let layout_binary_tree_1 root = 
	let rec aux left_start node depth = match node with
		| Empty -> (left_start,Empty)
		| Node(v,l,r) -> let left_num, left_tree = aux left_start l (depth+1) in
			let right_num, right_tree = aux (left_num+1) r (depth + 1) in
        	(right_num, Node((v, left_num, depth), left_tree, right_tree))
    in
	snd (aux 1 root 1)

val layout_binary_tree_1 : 'a binary_tree -> ('a * int * int) binary_tree =
  <fun>

```



```
# let layout_binary_tree_1 t =
    let rec layout depth x_left = function
      (* This function returns a pair: the laid out tree and the first
       * free x location *)
      | Empty -> (Empty, x_left)
      | Node (v,l,r) ->
         let (l', l_x_max) = layout (depth + 1) x_left l in
         let (r', r_x_max) = layout (depth + 1) (l_x_max + 1) r in
           (Node ((v, l_x_max, depth), l', r'), r_x_max)
    in
      fst (layout 1 1 t);;
val layout_binary_tree_1 : 'a binary_tree -> ('a * int * int) binary_tree =
  <fun>
```

### 57. Layout a Binary Tree (2)

> 
> ![Binary Tree Grid](https://ocaml.org/media/problems/tree-layout2.gif)
>
> An alternative layout method is depicted in this illustration. Find out the rules and write the corresponding OCaml function.
>
> **Hint:** On a given level, the horizontal distance between neighbouring nodes is constant.
>
> The tree shown is
>
> ```
> # let example_layout_tree =
>   let leaf x = Node (x, Empty, Empty) in
>   Node ('n', Node ('k', Node ('c', leaf 'a',
>                            Node ('e', leaf 'd', leaf 'g')),
>                  leaf 'm'),
>        Node ('u', Node ('p', Empty, leaf 'q'), Empty));;
> val example_layout_tree : char binary_tree =
>   Node ('n',
>    Node ('k',
>     Node ('c', Node ('a', Empty, Empty),
>      Node ('e', Node ('d', Empty, Empty), Node ('g', Empty, Empty))),
>     Node ('m', Empty, Empty)),
>    Node ('u', Node ('p', Empty, Node ('q', Empty, Empty)), Empty))
> # layout_binary_tree_2 example_layout_tree ;;
> - : (char * int * int) binary_tree =
> Node (('n', 15, 1),
>  Node (('k', 7, 2),
>   Node (('c', 3, 3), Node (('a', 1, 4), Empty, Empty),
>    Node (('e', 5, 4), Node (('d', 4, 5), Empty, Empty),
>     Node (('g', 6, 5), Empty, Empty))),
>   Node (('m', 11, 3), Empty, Empty)),
>  Node (('u', 23, 2),
>   Node (('p', 19, 3), Empty, Node (('q', 21, 4), Empty, Empty)), Empty))
> ```

初看麻烦，其实就是 2^n 的距离，需要先扫描一下最高层数。

# 总结

