---
layout: post
title: OCaml 99 问题笔记（Miscellaneous 部分）
date:  2024-9-13 21:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

这就全是那种接雨水类型的问题了吧。

### 75. Eight Queens Problem

> This is a classical problem in computer science. The objective is to place eight queens on a chessboard so that no two queens are attacking each other; i.e., no two queens are in the same row, the same column, or on the same diagonal.
>
> **Hint:** Represent the positions of the queens as a list of numbers 1..N. Example: `[4; 2; 7; 3; 6; 8; 5; 1]` means that the queen in the first column is in row 4, the queen in the second column is in row 2, etc. Use the generate-and-test paradigm.
>
> ```
> # queens_positions 4;;
> - : int list list = [[3; 1; 4; 2]; [2; 4; 1; 3]]
> ```

generate-and-test paradigm，神秘，不用回溯吗？`Generate and Test Search is a heuristic search technique based on Depth First Search with Backtracking which guarantees to find a solution if done systematically and there exists a solution.`哦，要回溯的。

我记得 LeetCode 有个 N 皇后，当时我就不会，这题还不太一样吗，题要 8 皇后，问题是例子里也没有 8 个啊，我就当 N 皇后做了。

```
let queens_positions max = 
	let adjacent (ac,ar) (bc,br) = 
		if (ac-bc) + (ar-br) = 0 || (ac-bc) = (ar-br) || ac = bc || ar = br then true else false
	in
	let rec aux row column queens = 
		if row>max then [queens] else
		if column > max then [] else
		let now = (row, column) in
		if any queens (fun q-> adjacent q now) then aux row (column+1) queens else
		aux (row+1) 1 (now::queens) @ aux row (column+1) queens
	in
	List.map (List.map snd) (aux 1 1 [])
```

少用了内存，没像我把元组存着，导致判定麻烦了点。也差不多。

> This is a brute force algorithm enumerating all possible solutions. For a deeper analysis, look for example to [Wikipedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle).
>
> ```
> # let possible row col used_rows usedD1 usedD2 =
>     not (List.mem row used_rows
>          || List.mem (row + col) usedD1
>          || List.mem (row - col) usedD2)
>          let queens_positions n =
>     let rec aux row col used_rows usedD1 usedD2 =
>       if col > n then [List.rev used_rows]
>       else
>         (if row < n then aux (row + 1) col used_rows usedD1 usedD2
>          else [])
>         @ (if possible row col used_rows usedD1 usedD2 then
>              aux 1 (col + 1) (row :: used_rows) (row + col :: usedD1)
>                  (row - col :: usedD2)
>            else [])
>     in aux 1 1 [] [] [];;
> val possible : int -> int -> int list -> int list -> int list -> bool = <fun>
> val queens_positions : int -> int list list = <fun>
> ```

### 76. Knight's Tour

> Another famous problem is this one: How can a knight jump on an N×N chessboard in such a way that it visits every square exactly once?
>
> **Hint:** Represent the squares by pairs of their coordinates `(x,y)`, where both `x` and `y` are integers between 1 and N. Define the function `jump n (x,y)` that returns all coordinates `(u,v)` to which a knight can jump from `(x,y)` to on a `n`×`n` chessboard. And finally, represent the solution of our problem as a list knight positions (the knight's tour).

还是国际象棋啊，巧了，最近我也玩了玩国象，线下和小兄弟还玩了玩。有时间可以打打 rank。



# 总结

​	
