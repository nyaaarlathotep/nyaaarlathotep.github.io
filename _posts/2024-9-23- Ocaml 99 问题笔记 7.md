---
layout: post
title: OCaml 99 问题笔记（Miscellaneous 部分）
date:  2024-9-13 21:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

这就全是那种接雨水类型的问题了吧。

### 75. Eight Queens Problem

> This is a classical problem in computer science. The objective is to place eight queens on a chessboard so that no two queens are attacking each other; i.e., no two queens are in the same row, the same column, or on the same diagonal.
>
> **Hint:** Represent the positions of the queens as a list of numbers 1..N. Example: `[4; 2; 7; 3; 6; 8; 5; 1]` means that the queen in the first column is in row 4, the queen in the second column is in row 2, etc. Use the generate-and-test paradigm.
>
> ```
> # queens_positions 4;;
> - : int list list = [[3; 1; 4; 2]; [2; 4; 1; 3]]
> ```

generate-and-test paradigm，神秘，不用回溯吗？`Generate and Test Search is a heuristic search technique based on Depth First Search with Backtracking which guarantees to find a solution if done systematically and there exists a solution.`哦，要回溯的。

我记得 LeetCode 有个 N 皇后，当时我就不会，这题还不太一样吗，题要 8 皇后，问题是例子里也没有 8 个啊，我就当 N 皇后做了。

```
let queens_positions max = 
	let adjacent (ac,ar) (bc,br) = 
		if (ac-bc) + (ar-br) = 0 || (ac-bc) = (ar-br) || ac = bc || ar = br then true else false
	in
	let rec aux row column queens = 
		if row>max then [queens] else
		if column > max then [] else
		let now = (row, column) in
		if any queens (fun q-> adjacent q now) then aux row (column+1) queens else
		aux (row+1) 1 (now::queens) @ aux row (column+1) queens
	in
	List.map (List.map snd) (aux 1 1 [])
```

少用了内存，没像我把元组存着，导致判定麻烦了点。也差不多。

> This is a brute force algorithm enumerating all possible solutions. For a deeper analysis, look for example to [Wikipedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle).
>
> ```
> # let possible row col used_rows usedD1 usedD2 =
>     not (List.mem row used_rows
>          || List.mem (row + col) usedD1
>          || List.mem (row - col) usedD2)
>          let queens_positions n =
>     let rec aux row col used_rows usedD1 usedD2 =
>       if col > n then [List.rev used_rows]
>       else
>         (if row < n then aux (row + 1) col used_rows usedD1 usedD2
>          else [])
>         @ (if possible row col used_rows usedD1 usedD2 then
>              aux 1 (col + 1) (row :: used_rows) (row + col :: usedD1)
>                  (row - col :: usedD2)
>            else [])
>     in aux 1 1 [] [] [];;
> val possible : int -> int -> int list -> int list -> int list -> bool = <fun>
> val queens_positions : int -> int list list = <fun>
> ```

### 76. Knight's Tour

> Another famous problem is this one: How can a knight jump on an N×N chessboard in such a way that it visits every square exactly once?
>
> **Hint:** Represent the squares by pairs of their coordinates `(x,y)`, where both `x` and `y` are integers between 1 and N. Define the function `jump n (x,y)` that returns all coordinates `(u,v)` to which a knight can jump from `(x,y)` to on a `n`×`n` chessboard. And finally, represent the solution of our problem as a list knight positions (the knight's tour).

还是国际象棋啊，巧了，最近我也玩了玩国象，线下和小兄弟还玩了玩。有时间可以打打 rank。不用所有可能吗，那还好，这个看起来回溯也会很大。

不多说了，这才叫可读性好吧。

癌，max = 6 的时候就让我的浏览器卡了一会，很恐怖好吧。

```
let knight_tour max = 
	let legal_next (x,y) steps= 
		let right_one = (x+1<=max) in
		let right_two = (x+2<=max) in
		let left_one = (x-1>=1) in
		let left_two = (x-2>=1) in
		let down_one = (y+1<=max) in
		let down_two = (y+2<=max) in
		let up_one = (y-1>=1) in
		let up_two = (y-2>=1) in
		let res = [] in
		let res = if right_one && down_two && (not (List.mem (x+1,y+2) steps)) 
        	then (x+1,y+2)::res else res in
		let res = if right_two && down_one && (not (List.mem (x+2,y+1) steps)) 
        	then (x+2,y+1)::res else res in
		let res = if right_one && up_two && (not (List.mem (x+1,y-2) steps)) 
        	then (x+1,y-2)::res else res in
		let res = if right_two && up_one && (not (List.mem (x+2,y-1) steps)) 
        	then (x+2,y-1)::res else res in
		let res = if left_one && down_two && (not (List.mem (x-1,y+2) steps)) 
        	then (x-1,y+2)::res else res in
		let res = if left_two && down_one && (not (List.mem (x-2,y+1) steps)) 
        	then (x-2,y+1)::res else res in
		let res = if left_one && up_two && (not (List.mem (x-1,y-2) steps)) 
        	then (x-1,y-2)::res else res in
		let res = if left_two && up_one && (not (List.mem (x-2,y-1) steps)) 
        	then (x-2,y-1)::res else res in
        res
        in
	let rec aux now steps = if List.length steps = max*max then Some steps else
		let nexts = legal_next now steps in
		if List.length nexts = 0 then None else
		let rec aaux remain_nexts = match remain_nexts with
			| [] -> None
			| h::t -> match aux h (h::steps) with
				| Some success -> Some success
				| None -> aaux t
        in
        aaux nexts
	in
	aux (1,1) [(1,1)]
```

### 77. Von Koch's Conjecture

> Several years ago I met a mathematician who was intrigued by a problem for which he didn't know a solution. His name was Von Koch, and I don't know whether the problem has been solved since.
>
> ![Tree numbering](https://ocaml.org/media/problems/von-koch1.gif)
>
> Anyway, the puzzle goes like this: Given a tree with N nodes (and hence N-1 edges). Find a way to enumerate the nodes from 1 to N and, accordingly, the edges from 1 to N-1 in such a way, that for each edge K the difference of its node numbers equals to K. The conjecture is that this is always possible.	
>
> For small trees the problem is easy to solve by hand. However, for larger trees, and 14 is already very large, it is extremely difficult to find a solution. And remember, we don't know for sure whether there is always a solution!
>
> ![Larger tree](https://ocaml.org/media/problems/von-koch2.gif)
>
> Write a function that calculates a numbering scheme for a given tree. What is the solution for the larger tree pictured here?

想起那道图相似的题了，就暴力排列求解呗。哦，这个还不太一样，洗牌的方式比较特别啊。

```
let rev_concat_map f l = List.fold_left (fun acc x -> List.rev_append (f x) acc) [] l

let (--) l x = List.filter ((<>)x) l

let rec permutation = function
| [] -> []
| x::[] -> [[x]]
| l -> rev_concat_map (fun x -> List.map (fun y -> x::y) (permutation (l--x))) l

let mappings l1 l2 = permutation l2 |> List.map (List.combine l1)

let vk_solution g = 
	let rec gen_node_num now r= match r with
		| [] -> []
		| h::t -> now:: (gen_node_num (now+1) t)
	in
	
	let node_num = gen_node_num 1 g.nodes in
	let possibilities = mappings g.nodes node_num in
	let total_edge = List.length g.edges in
	let pass map = 
		let rec check_edge remain_edges edge_nums= match remain_edges with
			| [] -> true
			| (a,b)::t -> let a_num = List.assoc a map in let b_num = List.assoc b map in
				let edge_num = if a_num>b_num then a_num-b_num else b_num-a_num in
				if not (List.mem edge_num edge_nums) && edge_num<=total_edge 
					then check_edge t (edge_num::edge_nums) 
				else false
		in
		check_edge g.edges []
	in
	List.filter (fun e -> pass e) possibilities
```

我服了，第二个例子果然卡死了，我遭得住啊。第一个例子看着是对的，这种还是得优化。过了吧。

### 78. An Arithmetic Puzzle

> Given a list of integer numbers, find a correct way of inserting arithmetic signs (operators) such that the result is a correct equation. Example: With the list of numbers `[2; 3; 5; 7; 11]` we can form the equations 2 - 3 + 5 + 7 = 11 or 2 = (3 * 5 + 7) / 11 (and ten others!).

不是，哥们，这是否有点，Spicy。

生成了好多，好多那种两个 list 互相结合衍生一堆小的那种情况，哇，好麻烦。

```
let find_equation l = 
	let make_success left right = 
		
	in
	let rec eval_poss list = 
		match list with
			| [] -> raise Not_found
			| [h] -> h
			| [a;b] -> 
				let a_str = string_of_int a in
				let a_str = string_of_int b in
				[(a+b, ["(";a_str;"+";b_str;")"]; (a-b,["(";a_str;"+";b_str;")"]); (a*b,["(";a_str;"+";b_str;")"]); (a/b,["(";a_str;"+";b_str;")"])]
            | a::b::t ->  let list1 = [(a+b, "(a+b)"), (a-b,("(a-b)")), (a*b,("a*b")), (a/b,"(a/b)")] in
            	let l2 = eval_poss t in
            	List.fold_left (
            		fun acc (l2ea,l2eb) ->  
            			let l2e_str = l2eb in
            			List.fold_left (fun inner_acc (l1ea,l1eb) -> 
            				let l1e_str = l1eb in
            				[(l1ea+l2eb, ["(";l1e_str;"+";l2e_str;")"]; (l1ea-l2eb,["(";l1e_str;"+";l2e_str;")"]); (l1ea*l2eb,["(";l1e_str;"+";l2e_str;")"]); (l1ea/l2eb,["(";l1e_str;"+";l2e_str;")"]] @ inner_acc
            			) acc l1 
            	) [] l2
	in
	let rec make_more remain left success = match remain with
		| [] -> raise Not_found
		| [e] -> success
		| h::t -> let left = h::left in
			make_more t left (success @ make_success left t)
	in
	make_more l [] []
```



### 79. English Number Words

> On financial documents, like cheques, numbers must sometimes be written in full words. Example: 175 must be written as one-seven-five. Write a function `full_words` to print (non-negative) integer numbers in full words.
>
> ```
> # full_words 175;;
> - : string = "one-seven-five"
> ```

``` 
let rec full_words n = 
	let table = [(0,"zero");(1,"one");(2,"two");(3,"three");(4,"four");(5,"five");(6,"six");(7,"seven");(8,"eight");(9,"nine")] in
	let rec aux num = 
		if num = 0 then [] else
		let last_num = num mod 10 in
		List.assoc last_num table :: aux ((num-last_num)/10)
	in
	let rec rev_join words splitor = match words with
		| [] -> ""
		| [h] -> h
		| h::t -> rev_join t splitor ^ splitor ^ h
	in
	rev_join (aux n) "-";;

val full_words : int -> string = <fun>

```

brilliant! There sure is array list in OCaml.

> ```
> # let full_words =
>     let digit = [|"zero"; "one"; "two"; "three"; "four"; "five"; "six";
>                   "seven"; "eight"; "nine"|] in
>     let rec words w n =
>       if n = 0 then (match w with [] -> [digit.(0)] | _ -> w)
>       else words (digit.(n mod 10) :: w) (n / 10)
>     in
>       fun n -> String.concat "-" (words [] n);;
> val full_words : int -> string = <fun>
> ```

### 80. Syntax Checker

> ![Syntax graph](https://ocaml.org/media/problems/syntax-graph.gif)
>
> In a certain programming language (Ada) identifiers are defined by the syntax diagram (railroad chart) opposite. Transform the syntax diagram into a system of syntax diagrams which do not contain loops; i.e. which are purely recursive. Using these modified diagrams, write a function `identifier : string -> bool` that can check whether or not a given string is a legal identifier.
>
> ```
> # identifier "this-is-a-long-identifier";;
> - : bool = true
> ```

regex?

```
let identifier exp = 
	let letter c = 'a' <= c && c <= 'z' in
    let num_or_letter c = letter c || ('0' <= c && c <= '9') in
    let len = String.length exp in
    if len = 0 then false else
    let rec other_word index underscore= 
    	if index >= len then true else
    	if exp.[index] = '-' && not underscore then false else
    	if exp.[index] = '-' then other_word (index+1) false else
        if num_or_letter exp.[index] then other_word (index+1) true else false
    in
    let rec start_word index underscore=
    	if index >= len then true else 
    	if exp.[index] = '-' && not underscore then false else
    	if exp.[index] = '-' then other_word index false else
        if letter exp.[index] then other_word (index+1) true else false
	in
	
    start_word 0 false
```

Zero length string is alse false.

> ```
> # let identifier =
>     let is_letter c = 'a' <= c && c <= 'z' in
>     let is_letter_or_digit c = is_letter c || ('0' <= c && c <= '9') in
>     let rec is_valid s i not_after_dash =
>       if i < 0 then not_after_dash
>       else if is_letter_or_digit s.[i] then is_valid s (i - 1) true
>       else if s.[i] = '-' && not_after_dash then is_valid s (i - 1) false
>       else false in
>     fun s -> (
>         let n = String.length s in
>       n > 0 && is_letter s.[n - 1] && is_valid s (n - 2) true);;
> val identifier : string -> bool = <fun>
> ```

### 81. Sudoku

> Sudoku puzzles go like this:
>
> ```text
>    Problem statement                 Solution
> 
>     .  .  4 | 8  .  . | .  1  7      9  3  4 | 8  2  5 | 6  1  7
>             |         |                      |         |
>     6  7  . | 9  .  . | .  .  .      6  7  2 | 9  1  4 | 8  5  3
>             |         |                      |         |
>     5  .  8 | .  3  . | .  .  4      5  1  8 | 6  3  7 | 9  2  4
>     --------+---------+--------      --------+---------+--------
>     3  .  . | 7  4  . | 1  .  .      3  2  5 | 7  4  8 | 1  6  9
>             |         |                      |         |
>     .  6  9 | .  .  . | 7  8  .      4  6  9 | 1  5  3 | 7  8  2
>             |         |                      |         |
>     .  .  1 | .  6  9 | .  .  5      7  8  1 | 2  6  9 | 4  3  5
>     --------+---------+--------      --------+---------+--------
>     1  .  . | .  8  . | 3  .  6      1  9  7 | 5  8  2 | 3  4  6
>             |         |                      |         |
>     .  .  . | .  .  6 | .  9  1      8  5  3 | 4  7  6 | 2  9  1
>             |         |                      |         |
>     2  4  . | .  .  1 | 5  .  .      2  4  6 | 3  9  1 | 5  7  8
> ```
>
> Every spot in the puzzle belongs to a (horizontal) row and a (vertical) column, as well as to one single 3x3 square (which we call "square" for short). At the beginning, some of the spots carry a single-digit number between 1 and 9. The problem is to fill the missing spots with digits in such a way that every number between 1 and 9 appears exactly once in each row, in each column, and in each square.
>
> ```
> # (* The board representation is not imposed.  Here "0" stands for "." *);;
> ```

How could I input the board?

# 总结

