---
layout: post
title: OCaml 99 问题笔记（Miscellaneous 部分）
date:  2024-9-13 21:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

这就全是那种接雨水类型的问题了吧。

### 75. Eight Queens Problem

> This is a classical problem in computer science. The objective is to place eight queens on a chessboard so that no two queens are attacking each other; i.e., no two queens are in the same row, the same column, or on the same diagonal.
>
> **Hint:** Represent the positions of the queens as a list of numbers 1..N. Example: `[4; 2; 7; 3; 6; 8; 5; 1]` means that the queen in the first column is in row 4, the queen in the second column is in row 2, etc. Use the generate-and-test paradigm.
>
> ```
> # queens_positions 4;;
> - : int list list = [[3; 1; 4; 2]; [2; 4; 1; 3]]
> ```

generate-and-test paradigm，神秘，不用回溯吗？`Generate and Test Search is a heuristic search technique based on Depth First Search with Backtracking which guarantees to find a solution if done systematically and there exists a solution.`哦，要回溯的。

我记得 LeetCode 有个 N 皇后，当时我就不会，这题还不太一样吗，题要 8 皇后，问题是例子里也没有 8 个啊，我就当 N 皇后做了。

```
let queens_positions max = 
	let adjacent (ac,ar) (bc,br) = 
		if (ac-bc) + (ar-br) = 0 || (ac-bc) = (ar-br) || ac = bc || ar = br then true else false
	in
	let rec aux row column queens = 
		if row>max then [queens] else
		if column > max then [] else
		let now = (row, column) in
		if any queens (fun q-> adjacent q now) then aux row (column+1) queens else
		aux (row+1) 1 (now::queens) @ aux row (column+1) queens
	in
	List.map (List.map snd) (aux 1 1 [])
```

少用了内存，没像我把元组存着，导致判定麻烦了点。也差不多。

> This is a brute force algorithm enumerating all possible solutions. For a deeper analysis, look for example to [Wikipedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle).
>
> ```
> # let possible row col used_rows usedD1 usedD2 =
>     not (List.mem row used_rows
>          || List.mem (row + col) usedD1
>          || List.mem (row - col) usedD2)
>          let queens_positions n =
>     let rec aux row col used_rows usedD1 usedD2 =
>       if col > n then [List.rev used_rows]
>       else
>         (if row < n then aux (row + 1) col used_rows usedD1 usedD2
>          else [])
>         @ (if possible row col used_rows usedD1 usedD2 then
>              aux 1 (col + 1) (row :: used_rows) (row + col :: usedD1)
>                  (row - col :: usedD2)
>            else [])
>     in aux 1 1 [] [] [];;
> val possible : int -> int -> int list -> int list -> int list -> bool = <fun>
> val queens_positions : int -> int list list = <fun>
> ```

### 76. Knight's Tour

> Another famous problem is this one: How can a knight jump on an N×N chessboard in such a way that it visits every square exactly once?
>
> **Hint:** Represent the squares by pairs of their coordinates `(x,y)`, where both `x` and `y` are integers between 1 and N. Define the function `jump n (x,y)` that returns all coordinates `(u,v)` to which a knight can jump from `(x,y)` to on a `n`×`n` chessboard. And finally, represent the solution of our problem as a list knight positions (the knight's tour).

还是国际象棋啊，巧了，最近我也玩了玩国象，线下和小兄弟还玩了玩。有时间可以打打 rank。不用所有可能吗，那还好，这个看起来回溯也会很大。

不多说了，这才叫可读性好吧。

癌，max = 6 的时候就让我的浏览器卡了一会，很恐怖好吧。

```
let knight_tour max = 
	let legal_next (x,y) steps= 
		let right_one = (x+1<=max) in
		let right_two = (x+2<=max) in
		let left_one = (x-1>=1) in
		let left_two = (x-2>=1) in
		let down_one = (y+1<=max) in
		let down_two = (y+2<=max) in
		let up_one = (y-1>=1) in
		let up_two = (y-2>=1) in
		let res = [] in
		let res = if right_one && down_two && (not (List.mem (x+1,y+2) steps)) 
        	then (x+1,y+2)::res else res in
		let res = if right_two && down_one && (not (List.mem (x+2,y+1) steps)) 
        	then (x+2,y+1)::res else res in
		let res = if right_one && up_two && (not (List.mem (x+1,y-2) steps)) 
        	then (x+1,y-2)::res else res in
		let res = if right_two && up_one && (not (List.mem (x+2,y-1) steps)) 
        	then (x+2,y-1)::res else res in
		let res = if left_one && down_two && (not (List.mem (x-1,y+2) steps)) 
        	then (x-1,y+2)::res else res in
		let res = if left_two && down_one && (not (List.mem (x-2,y+1) steps)) 
        	then (x-2,y+1)::res else res in
		let res = if left_one && up_two && (not (List.mem (x-1,y-2) steps)) 
        	then (x-1,y-2)::res else res in
		let res = if left_two && up_one && (not (List.mem (x-2,y-1) steps)) 
        	then (x-2,y-1)::res else res in
        res
        in
	let rec aux now steps = if List.length steps = max*max then Some steps else
		let nexts = legal_next now steps in
		if List.length nexts = 0 then None else
		let rec aaux remain_nexts = match remain_nexts with
			| [] -> None
			| h::t -> match aux h (h::steps) with
				| Some success -> Some success
				| None -> aaux t
        in
        aaux nexts
	in
	aux (1,1) [(1,1)]
```

### 77. Von Koch's Conjecture

> Several years ago I met a mathematician who was intrigued by a problem for which he didn't know a solution. His name was Von Koch, and I don't know whether the problem has been solved since.
>
> ![Tree numbering](https://ocaml.org/media/problems/von-koch1.gif)
>
> Anyway, the puzzle goes like this: Given a tree with N nodes (and hence N-1 edges). Find a way to enumerate the nodes from 1 to N and, accordingly, the edges from 1 to N-1 in such a way, that for each edge K the difference of its node numbers equals to K. The conjecture is that this is always possible.	
>
> For small trees the problem is easy to solve by hand. However, for larger trees, and 14 is already very large, it is extremely difficult to find a solution. And remember, we don't know for sure whether there is always a solution!
>
> ![Larger tree](https://ocaml.org/media/problems/von-koch2.gif)
>
> Write a function that calculates a numbering scheme for a given tree. What is the solution for the larger tree pictured here?

想起那道图相似的题了，就暴力排列求解呗。哦，这个还不太一样，洗牌的方式比较特别啊。

```
let rev_concat_map f l = List.fold_left (fun acc x -> List.rev_append (f x) acc) [] l

let (--) l x = List.filter ((<>)x) l

let rec permutation = function
| [] -> []
| x::[] -> [[x]]
| l -> rev_concat_map (fun x -> List.map (fun y -> x::y) (permutation (l--x))) l

let mappings l1 l2 = permutation l2 |> List.map (List.combine l1)

let vk_solution g = 
	let rec gen_node_num now r= match r with
		| [] -> []
		| h::t -> now:: (gen_node_num (now+1) t)
	in
	
	let node_num = gen_node_num 1 g.nodes in
	let possibilities = mappings g.nodes node_num in
	let total_edge = List.length g.edges in
	let pass map = 
		let rec check_edge remain_edges edge_nums= match remain_edges with
			| [] -> true
			| (a,b)::t -> let a_num = List.assoc a map in let b_num = List.assoc b map in
				let edge_num = if a_num>b_num then a_num-b_num else b_num-a_num in
				if not (List.mem edge_num edge_nums) && edge_num<=total_edge 
					then check_edge t (edge_num::edge_nums) 
				else false
		in
		check_edge g.edges []
	in
	List.filter (fun e -> pass e) possibilities
```

我服了，第二个例子果然卡死了，我遭得住啊。第一个例子看着是对的，这种还是得优化。过了吧。

### 78. An Arithmetic Puzzle

> Given a list of integer numbers, find a correct way of inserting arithmetic signs (operators) such that the result is a correct equation. Example: With the list of numbers `[2; 3; 5; 7; 11]` we can form the equations 2 - 3 + 5 + 7 = 11 or 2 = (3 * 5 + 7) / 11 (and ten others!).

不是，哥们，这是否有点。Spicy.

# 总结

