---
layout: post
title: OCaml 99 问题笔记（Arithmetic 部分）
date:  2024-8-2 9:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 笔记

似乎这一部分都是涉及最大公因数之类的数学类的内容。

### 30. Determine Whether a Given Integer Number Is Prime

印象里应该有更简单的方法。

```
let is_prime n = 
	let limit = int_of_float ((float_of_int n +. 0.5) ** 0.5) in
	let rec aux now num = 
		if now = 1 then true 
		else if n mod now = 0 then false 
		else aux (now-1) num in
    aux limit n;;

val is_prime : int -> bool = <fun>

```

差不多一个意思。我先开了方，由最大可能向下计算，不用每个数都进行一次平方后比较了，它为什么要这么做呢，一次开方效率这么低吗？

果然答案介绍了个更简单的方法。[Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)

牛啊牛啊，但这个能用到这一题上吗？这一题不是要判断是否为质数吗，难道每判断一次算一次？

```
# let is_prime n =
        let n = abs n in
    let rec is_not_divisor d =
      d * d > n || (n mod d <> 0 && is_not_divisor (d + 1)) in
    n > 1 && is_not_divisor 2;;
val is_prime : int -> bool = <fun>

```

### 31. Determine the Greatest Common Divisor of Two Positive Integer Numbers

辗转相除法

```
let rec gcd a b = 
	let (a,b) = if a> b then (a,b) else (b,a) in
	if a mod b = 0 then b
	else gcd (a mod b) b;;

val gcd : int -> int -> int = <fun>

```

标注答案巧妙的交换了下顺序，就不用额外处理谁大谁小的问题了，巧妙啊。

```
# let rec gcd a b =
    if b = 0 then a else gcd b (a mod b);;
val gcd : int -> int -> int = <fun>

```

### 32. Determine Whether Two Positive Integer Numbers Are Coprime

赖皮赖皮

```
let coprime a b =
	if gcd a b = 1 then true else false;;

val coprime : int -> int -> bool = <fun>

```

```
# (* [gcd] is defined in the previous question *)
  let coprime a b = gcd a b = 1;;
val coprime : int -> int -> bool = <fun>

```

### 33. Calculate Euler's Totient Function Φ(m)

Euler's so-called totient function φ(m) is defined as the number of positive integers r (1 ≤ r < m) that are coprime to m. We let φ(1) = 1.

Find out what the value of φ(m) is if m is a prime number. Euler's totient function plays an important role in one of the most widely used public key cryptography methods (RSA). In this exercise you should use the most primitive method to calculate this function (there are smarter ways that we shall discuss later).

描述都说了后面再优化，那这个皮非赖不可了。

```
let phi n = 
	let rec aux n now =
    	if now = 1 then 1
		else if coprime now n then 1 + (aux n (now-1))
		else aux n (now-1) 
	in
	aux n (n-1);;

val phi : int -> int = <fun>

```

```
# (* [coprime] is defined in the previous question *)
  let phi n =
    let rec count_coprime acc d =
      if d < n then
        count_coprime (if coprime n d then acc + 1 else acc) (d + 1)
      else acc
    in
      if n = 1 then 1 else count_coprime 0 1;;
val phi : int -> int = <fun>

```

# 总结

有点感觉了。list 类的这几道题我拖了很久才做完，简单的还好，中等的做的我有点汗流浃背了，暂时还没遇到困难的，不知道啥时候能做完。

OCaml 这个类型判断是有问题还是我写的问题？

很多我的和标准答案的答案都有差距啊。
