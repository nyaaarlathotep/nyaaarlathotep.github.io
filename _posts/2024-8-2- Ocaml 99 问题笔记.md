---
layout: post
title: OCaml 99 问题笔记
date:  2024-8-2 9:00:00 +0900
description: 学了点 FP，趁热打铁，试试 OCaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 前言

> This section is inspired by Ninety-Nine Lisp Problems which in turn was based on “Prolog problem list” by Werner Hett.

原来是 Lisp 的问题改过来的，还得是认祖归宗啊。

# 笔记

### 1. Write a function last : 'a list -> 'a option that returns the last element of a list

判断列表长度，match 长度处理。

```
let last l= 
  let len = List.length l in
  match len with
  | 0 -> Option.none
  | _ -> let pos = len-1 in 
    List.nth_opt l pos;;

val last : 'a list -> 'a option = <fun>
```

其实可以直接 match list 的，切片递归处理，有点 Scheme 的意思了，OCaml 这个模式匹配还比 Scheme 的 car 和 cdr 更灵活。

```
# let rec last = function 
  | [] -> None
  | [ x ] -> Some x
  | _ :: t -> last t;;
val last : 'a list -> 'a option = <fun>
```

### 2. Find the last but one (last and penultimate) elements of a list.

我猜测可能有什么语法糖。

```
# let rec last_two = function 
  | [] -> None
  | a::[] -> None
  | a::b::[] -> Some (a,b)
  | _ :: t -> last t;;

val last_two : 'a list -> ('a * 'a) option = <fun>
```

```
# let rec last_two = function
    | [] | [_] -> None
    | [x; y] -> Some (x,y)
    | _ :: t -> last_two t;;
val last_two : 'a list -> ('a * 'a) option = <fun>
```

### 3. N'th Element of a List

Find the N'th element of a list.

啥意思，给了库函数了都，用递归改写一下吗？

```
let rec at k = function
    | [] -> None
    | h :: t -> if k = 0 then Some h else at (k - 1) t;;

val at : int -> 'a list -> 'a option = <fun>
```

### 4. Length of a List

Find the number of elements of a list.

这是 continuation 啊，来了来了。

```
let rec length = function
  | [] -> 0
  | _ :: t -> let remain = length t in 1 + remain;;

val length : 'a list -> int = <fun>
```

哦？也行。

```
# let length list =
    let rec aux n = function
      | [] -> n
      | _ :: t -> aux (n + 1) t
    in
    aux 0 list;;
val length : 'a list -> int = <fun>
```
### 5. Reverse a list.

直接用 append 了，我感觉应该有别的好办法，在 OCaml 里怎么切片呢？或者 match 还有什么语法糖？

```
let rec rev = function
  | [] -> []
  | [a] -> [a]
  | h :: t -> let res = rev t in List.append res [h];;

val rev : 'a list -> 'a list = <fun>
```

哦，弱智了。

```
# let rev list =
    let rec aux acc = function
      | [] -> acc
      | h :: t -> aux (h :: acc) t
    in
    aux [] list;;
val rev : 'a list -> 'a list = <fun>
```
### 6. Palindrome

Find out whether a list is a palindrome.

OCaml 里怎么比较两个基本类型相等？哦，强啊。是不是有递归做法？我还是不知道怎么切片。

```
let is_palindrome s = 
  let pa_s= rev s in
  List.equal (=) pa_s s;;

val is_palindrome : 'a list -> bool = <fun>
```

哎，想多了，原来 list 能直接 = 的。== 好像是比较地址。

```
# let is_palindrome list =
    (* One can use either the rev function from the previous problem, or the built-in List.rev *)
    list = List.rev list;;
val is_palindrome : 'a list -> bool = <fun>
```

### 7. Flatten a List

Flatten a nested list structure.

```
type 'a node =
  | One of 'a 
  | Many of 'a node list;;

type 'a node = One of 'a | Many of 'a node list

let rec flatten l = match l with
  | [] -> []
  | One x :: t -> let res= flatten t in 
    List.cons x res
  | Many list :: t -> let h= flatten list in 
    let res= flatten t in 
    List.append h res;;

val flatten : 'a node list -> 'a list = <fun>
```

标准答案 rev 了一下，为了避免将一个 list 顺序 cons 到另一个上这个操作，也就是 List.append，我查下 a little Scheme 里怎么做的。书里面好像没有。

append 好像也得用 rev 和 cons 一起实现，这个 rev 似乎避免不了。

```
# type 'a node =
    | One of 'a 
    | Many of 'a node list;;
type 'a node = One of 'a | Many of 'a node list
# (* This function traverses the list, prepending any encountered elements
    to an accumulator, which flattens the list in inverse order. It can
    then be reversed to obtain the actual flattened list. *);;
# let flatten list =
    let rec aux acc = function
      | [] -> acc
      | One x :: t -> aux (x :: acc) t
      | Many l :: t -> aux (aux acc l) t
    in
    List.rev (aux [] list);;
val flatten : 'a node list -> 'a list = <fun>
```

### 8. Eliminate Duplicates

Eliminate consecutive duplicates of list elements.

没仔细读题，题意不是去重，而是去连续的重。写成那个 rember 了。

```
let rec compress l =
  match l with
  | [] -> []
  | h :: t -> if List.exists ((=) h) t then compress t else List.cons h (compress t);;

val compress : 'a list -> 'a list = <fun>
```

可以可以，还能这么玩，想想在 Scheme 里要处理这种留存上一个元素状态的情况真有点麻烦，只能带着状态传下去用 cond 判断了。

```
# let rec compress = function
    | a :: (b :: _ as t) -> if a = b then compress t else a :: compress t
    | smaller -> smaller;;
val compress : 'a list -> 'a list = <fun>
```

### 9. Pack Consecutive Duplicates

Pack consecutive duplicates of list elements into sublists.

有一些开始和结束的空列表会被错误的添加入结果中，要是用 if 排除又太过丑陋，我想想能否优化一下。

```
let pack l= 
  let rec rec_pack r rune_l remain_l = 
    match remain_l with
    | [] -> [rune_l]
    | h::t -> if h = r then let new_rune_l = (List.cons h rune_l) in rec_pack h new_rune_l t 
      else List.cons rune_l (rec_pack h [h] t) in
  rec_pack "" [] l;;

val pack : string list -> string list list = <fun>
```

按这个思路好像是能用 Option 再简化一下，有点麻烦。

哎，差不多，标准答案又是那个要 rev 一下的。还是多用 :: 少用 List.cons 吧，确实美观一点，入参只是空格分开实在影响可读性。

标准答案的这几个都是将最后的返回作为参数一步步传入，因此都是逆序 cons 到最后结果的列表上的，自然最后需要逆序一下。可以理解。为啥不爱用 continuation 呢。

```
# let pack list =
    let rec aux current acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (x :: current) :: acc
  `    | a :: (b :: _ as t) ->
         if a = b then aux (a :: current) acc t
         else aux [] ((a :: current) :: acc) t  in
    List.rev (aux [] [] list);;
val pack : 'a list -> 'a list list = <fun>
```

### 10. Run-Length Encoding

抄第九道搞出来的，有没有更简单的方法呢？

```
let encode list =
    let rec encode_rec num acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (num + 1, x) :: acc
      | a :: ((b :: _) as t) ->
         if a = b then encode_rec num + 1 acc t
         else encode_rec 0 ((num + 1, a):: acc) t in
    List.rev (encode_rec  0 [] list);;
```

把递归向下传递的参数优化了一下，只传当前字符已经重复了的次数即可。

```
let encode list =
    let rec encode_rec num acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (num + 1, x) :: acc
      | a :: ((b :: _) as t) ->
         if a = b then encode_rec (num + 1) acc t
         else encode_rec 0 ((num + 1, a):: acc) t in
    List.rev (encode_rec  0 [] list);;

val encode : 'a list -> (int * 'a) list = <fun>
```

差不多，用 pack 的那个有点意思，用了 List.map 把 pack 的结果 map 过去了，挺好。

```
# let encode list =
    let rec aux count acc = function
      | [] -> [] (* Can only be reached if original list is empty *)
      | [x] -> (count + 1, x) :: acc
      | a :: (b :: _ as t) -> if a = b then aux (count + 1) acc t
                              else aux 0 ((count + 1, a) :: acc) t in
    List.rev (aux 0 [] list);;
val encode : 'a list -> (int * 'a) list = <fun>

(* An alternative solution, which is shorter but requires more memory, 
is to use the pack function declared in problem 9: *)

# let pack list =
    let rec aux current acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (x :: current) :: acc
      | a :: (b :: _ as t) ->
         if a = b then aux (a :: current) acc t
         else aux [] ((a :: current) :: acc) t  in
    List.rev (aux [] [] list);;
val pack : 'a list -> 'a list list = <fun>
# let encode list =
    List.map (fun l -> (List.length l, List.hd l)) (pack list);;
val encode : 'a list -> (int * 'a) list = <fun>
```

### 11. Modified Run-Length Encoding

Modify the result of the previous problem in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as (N E) lists.

又用到了 10 题，感觉还能简化下，一遍遍历完成。

```
type 'a rle =
  | One of 'a
  | Many of int * 'a;;

let encode l= 
  let inner_encode list =
    let rec aux count acc = function
      | [] -> [] (* Can only be reached if original list is empty *)
      | [x] -> (count + 1, x) :: acc
      | a :: (b :: _ as t) -> if a = b then aux (count + 1) acc t
                              else aux 0 ((count + 1, a) :: acc) t in
    List.rev (aux 0 [] list) in
  List.map (fun e -> (let (x, y)= e in if x >1 then Many (x, y) else One y)) (inner_encode l);;
```

```
# type 'a rle =
  | One of 'a
  | Many of int * 'a;;
type 'a rle = One of 'a | Many of int * 'a
# let encode l =
    let create_tuple cnt elem =
      if cnt = 1 then One elem
      else Many (cnt, elem) in
    let rec aux count acc = function
      | [] -> []
      | [x] -> (create_tuple (count + 1) x) :: acc
      | hd :: (snd :: _ as tl) ->
          if hd = snd then aux (count + 1) acc tl
          else aux 0 ((create_tuple (count + 1) hd) :: acc) tl in
      List.rev (aux 0 [] l);;
val encode : 'a list -> 'a rle list = <fun>

```

### 12. Decode a Run-Length Encoded List

可以直接 map 再用 List.append reduce 一下，或者 flatten。

或者有几个就 cons 几个，然后 rev。

```
let rec decode l = 
	let rec multi_cons e cnt acc=
    	if cnt >0 then (multi_cons e (cnt-1) (List.cons e acc)) else acc 
    in
	let rec inner_decode l acc= 
		match l with
		| [] -> acc
		| h::(t) -> match h with
			| One e -> inner_decode t (List.cons e acc)
			| Many (cnt, e) -> inner_decode t (List.append (multi_cons e cnt []) acc)
	in
	List.rev (inner_decode l [])
```

简化

```
let decode l = 
	let rec multi_cons e cnt acc=
    	if cnt >0 then (multi_cons e (cnt-1) (List.cons e acc)) else acc 
    in
    let match_e e= match e with
		| One e -> [e]
		| Many (cnt, e) -> multi_cons e cnt []
	in
	List.flatten (List.map match_e l);;

val decode : 'a rle list -> 'a list list = <fun>

```

哦，和我第一个思路差不多，先 rev 了 list，因为后面增加元素了，更节约一点。

```
# let decode list =
    let rec many acc n x =
      if n = 0 then acc else many (x :: acc) (n - 1) x
    in
    let rec aux acc = function
      | [] -> acc
      | One x :: t -> aux (x :: acc) t
      | Many (n, x) :: t -> aux (many acc n x) t
    in
      aux [] (List.rev list);;
val decode : 'a rle list -> 'a list = <fun>

```

### 13. Run-Length Encoding of a List (Direct Solution)

Implement the so-called run-length encoding data compression method directly.

按这个意思我已经实现了。

### 14. Duplicate the Elements of a List

Duplicate the elements of a list.

还就是那个 Continuation。

```
let rec duplicate l = match l with
	| [] -> []
	| h::(t) -> List.cons h (List.cons h (duplicate t));;

val duplicate : 'a list -> 'a list = <fun>
```

哦，又忘了用 ::

```
# let rec duplicate = function
    | [] -> []
    | h :: t -> h :: h :: duplicate t;;
val duplicate : 'a list -> 'a list = <fun>
```

### 15. Replicate the Elements of a List a Given Number of Times

可以的，还是 Continuation，好！

```
let rec replicate l cnt = 
	let rec dup h cnt remain=
		if cnt >0 then h::(dup h (cnt-1) remain) else remain
	in
	match l with
		| [] -> []
		| h::t -> dup h cnt (replicate t cnt);;

val replicate : 'a list -> int -> 'a list = <fun>
```

我怎么感觉我的比他的好，标准答案擅长用 rev，读起来有点混乱。

确实，不知道是不是存在递归消耗之类原因导致他选择使用这种方式，他的明显多了一次 rev 的消耗。

```
# let replicate list n =
    let rec prepend n acc x =
      if n = 0 then acc else prepend (n-1) (x :: acc) x in
    let rec aux acc = function
      | [] -> acc
      | h :: t -> aux (prepend n acc h) t in
    (* This could also be written as:
       List.fold_left (prepend n) [] (List.rev list) *)
    aux [] (List.rev list);;
val replicate : 'a list -> int -> 'a list = <fun>
```

### 16. Drop Every N'th Element From a List

感觉这个反而很基础啊。

```
let rec drop l i=match l with
	| h::t ->  if i > 1 then h::drop t (i-1) else t;;

Lines 1-2, characters 17-48:
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]

val drop : 'a list -> int -> 'a list = <fun>
```

partial-match 了，意思到了就行。

为啥特意还搞一个内部函数呢，还把 index 转了一下，神秘

```
# let drop list n =
    let rec aux i = function
      | [] -> []
      | h :: t -> if i = n then aux 1 t else h :: aux (i + 1) t  in
    aux 1 list;;
val drop : 'a list -> int -> 'a list = <fun>

```

### 17. Split a List Into Two Parts; The Length of the First Part Is Given



# 总结
