---
layout: post
title: OCaml 99 问题笔记
date:  2024-8-2 9:00:00 +0900
description: 学了点 FP，趁热打铁，试试 ocaml 和他的这些函数式问题。
categories: [FP, OCaml]
keywords: OCaml
essays: true   
---

# 前言

> This section is inspired by Ninety-Nine Lisp Problems which in turn was based on “Prolog problem list” by Werner Hett.

原来是 Lisp 的问题改过来的，还得是认祖归宗啊。

# 笔记

1. Write a function last : 'a list -> 'a option that returns the last element of a list

判断列表长度，match 长度处理。

```
let last l= 
  let len = List.length l in
  match len with
  | 0 -> Option.none
  | _ -> let pos = len-1 in 
    List.nth_opt l pos;;

val last : 'a list -> 'a option = <fun>
```

其实可以直接 match list 的，切片递归处理，有点 Scheme 的意思了，OCaml 这个模式匹配还比 Scheme 的 car 和 cdr 更灵活。

```
# let rec last = function 
  | [] -> None
  | [ x ] -> Some x
  | _ :: t -> last t;;
val last : 'a list -> 'a option = <fun>
```

2. Find the last but one (last and penultimate) elements of a list.

我猜测可能有什么语法糖。

```
# let rec last_two = function 
  | [] -> None
  | a::[] -> None
  | a::b::[] -> Some (a,b)
  | _ :: t -> last t;;

val last_two : 'a list -> ('a * 'a) option = <fun>
```

```
# let rec last_two = function
    | [] | [_] -> None
    | [x; y] -> Some (x,y)
    | _ :: t -> last_two t;;
val last_two : 'a list -> ('a * 'a) option = <fun>
```

3. N'th Element of a List

Find the N'th element of a list.

啥意思，给了库函数了都，用递归改写一下吗？

```
let rec at k = function
    | [] -> None
    | h :: t -> if k = 0 then Some h else at (k - 1) t;;

val at : int -> 'a list -> 'a option = <fun>
```

4. Length of a List

Find the number of elements of a list.

这是 continuation 啊，来了来了。

```
let rec length = function
  | [] -> 0
  | _ :: t -> let remain = length t in 1 + remain;;

val length : 'a list -> int = <fun>
```

哦？也行。

```
# let length list =
    let rec aux n = function
      | [] -> n
      | _ :: t -> aux (n + 1) t
    in
    aux 0 list;;
val length : 'a list -> int = <fun>
```
5. Reverse a list.

直接用 append 了，我感觉应该有别的好办法，在 OCaml 里怎么切片呢？或者 match 还有什么语法糖？

```
let rec rev = function
  | [] -> []
  | [a] -> [a]
  | h :: t -> let res = rev t in List.append res [h];;

val rev : 'a list -> 'a list = <fun>
```

哦，弱智了。

```
# let rev list =
    let rec aux acc = function
      | [] -> acc
      | h :: t -> aux (h :: acc) t
    in
    aux [] list;;
val rev : 'a list -> 'a list = <fun>
```
6. Palindrome

Find out whether a list is a palindrome.

OCaml 里怎么比较两个基本类型相等？哦，强啊。是不是有递归做法？我还是不知道怎么切片。

```
let is_palindrome s = 
  let pa_s= rev s in
  List.equal (=) pa_s s;;

val is_palindrome : 'a list -> bool = <fun>
```

哎，想多了，原来 list 能直接 = 的。== 好像是比较地址。

```
# let is_palindrome list =
    (* One can use either the rev function from the previous problem, or the built-in List.rev *)
    list = List.rev list;;
val is_palindrome : 'a list -> bool = <fun>
```

7. Flatten a List

Flatten a nested list structure.

```
type 'a node =
  | One of 'a 
  | Many of 'a node list;;

type 'a node = One of 'a | Many of 'a node list

let rec flatten l = match l with
  | [] -> []
  | One x :: t -> let res= flatten t in 
    List.cons x res
  | Many list :: t -> let h= flatten list in 
    let res= flatten t in 
    List.append h res;;

val flatten : 'a node list -> 'a list = <fun>
```

标准答案 rev 了一下，为了避免将一个 list 顺序 cons 到另一个上这个操作，也就是 List.append，我查下 a little Scheme 里怎么做的。书里面好像没有。

append 好像也得用 rev 和 cons 一起实现，这个 rev 似乎避免不了。

```
# type 'a node =
    | One of 'a 
    | Many of 'a node list;;
type 'a node = One of 'a | Many of 'a node list
# (* This function traverses the list, prepending any encountered elements
    to an accumulator, which flattens the list in inverse order. It can
    then be reversed to obtain the actual flattened list. *);;
# let flatten list =
    let rec aux acc = function
      | [] -> acc
      | One x :: t -> aux (x :: acc) t
      | Many l :: t -> aux (aux acc l) t
    in
    List.rev (aux [] list);;
val flatten : 'a node list -> 'a list = <fun>
```

8. Eliminate Duplicates

Eliminate consecutive duplicates of list elements.

没仔细读题，题意不是去重，而是去连续的重。写成那个 rember 了。

```
let rec compress l =
  match l with
  | [] -> []
  | h :: t -> if List.exists ((=) h) t then compress t else List.cons h (compress t);;

val compress : 'a list -> 'a list = <fun>
```

可以可以，还能这么玩，想想在 Scheme 里要处理这种留存上一个元素状态的情况真有点麻烦，只能带着状态传下去用 cond 判断了。

```
# let rec compress = function
    | a :: (b :: _ as t) -> if a = b then compress t else a :: compress t
    | smaller -> smaller;;
val compress : 'a list -> 'a list = <fun>
```

9. Pack Consecutive Duplicates

Pack consecutive duplicates of list elements into sublists.

有一些开始和结束的空列表会被错误的添加入结果中，要是用 if 排除又太过丑陋，我想想能否优化一下。

```
let pack l= 
  let rec rec_pack r rune_l remain_l = 
    match remain_l with
    | [] -> [rune_l]
    | h::t -> if h = r then let new_rune_l = (List.cons h rune_l) in rec_pack h new_rune_l t 
      else List.cons rune_l (rec_pack h [h] t) in
  rec_pack "" [] l;;

val pack : string list -> string list list = <fun>
```

按这个思路好像是能用 Option 再简化一下，有点麻烦。

哎，差不多，标准答案又是那个要 rev 一下的。还是多用 :: 少用 List.cons 吧，确实美观一点，入参只是空格分开实在影响可读性。

标准答案的这几个都是将最后的返回作为参数一步步传入，因此都是逆序 cons 到最后结果的列表上的，自然最后需要逆序一下。可以理解。为啥不爱用 continuation 呢。

```
# let pack list =
    let rec aux current acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (x :: current) :: acc
  `    | a :: (b :: _ as t) ->
         if a = b then aux (a :: current) acc t
         else aux [] ((a :: current) :: acc) t  in
    List.rev (aux [] [] list);;
val pack : 'a list -> 'a list list = <fun>
```

10. Run-Length Encoding

抄第九道搞出来的，有没有更简单的方法呢？

```
let encode list =
    let rec encode_rec num acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (num + 1, x) :: acc
      | a :: ((b :: _) as t) ->
         if a = b then encode_rec num + 1 acc t
         else encode_rec 0 ((num + 1, a):: acc) t in
    List.rev (encode_rec  0 [] list);;
```

把递归向下传递的参数优化了一下，只传当前字符已经重复了的次数即可。

```
let encode list =
    let rec encode_rec num acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (num + 1, x) :: acc
      | a :: ((b :: _) as t) ->
         if a = b then encode_rec (num + 1) acc t
         else encode_rec 0 ((num + 1, a):: acc) t in
    List.rev (encode_rec  0 [] list);;

val encode : 'a list -> (int * 'a) list = <fun>
```

差不多，用 pack 的那个有点意思，用了 List.map 把 pack 的结果 map 过去了，挺好。

```
# let encode list =
    let rec aux count acc = function
      | [] -> [] (* Can only be reached if original list is empty *)
      | [x] -> (count + 1, x) :: acc
      | a :: (b :: _ as t) -> if a = b then aux (count + 1) acc t
                              else aux 0 ((count + 1, a) :: acc) t in
    List.rev (aux 0 [] list);;
val encode : 'a list -> (int * 'a) list = <fun>

(* An alternative solution, which is shorter but requires more memory, is to use the pack function declared in problem 9: *)

# let pack list =
    let rec aux current acc = function
      | [] -> []    (* Can only be reached if original list is empty *)
      | [x] -> (x :: current) :: acc
      | a :: (b :: _ as t) ->
         if a = b then aux (a :: current) acc t
         else aux [] ((a :: current) :: acc) t  in
    List.rev (aux [] [] list);;
val pack : 'a list -> 'a list list = <fun>
# let encode list =
    List.map (fun l -> (List.length l, List.hd l)) (pack list);;
val encode : 'a list -> (int * 'a) list = <fun>
```

# 总结
